\chapter{命题逻辑}
逻辑，是英文单词 logic 的音译.
逻辑学是研究思维形式、思维方法及思维规律尤其是推理的学科.
早在两千多年前，古希腊逻辑学家亚里士多德创立了形式逻辑（formal logic），
详细讨论概念（词项）、判断（命题）和各种形式的推理，
研究逻辑基本规律等内容.

德国数学家、哲学家莱布尼茨首先提出用数学方法研究逻辑，
即建立一套表意符号体系，在符号之间进行形式推理，
由此创立了数理逻辑（mathematical logic）.

现在，除了传统的数理逻辑（内容包括逻辑演算、公理化集合论、模型论、递归论和证明论）以外，
还出现了各种各样的应用逻辑，诸如
多值逻辑、模态逻辑、归纳逻辑、时序逻辑、动态逻辑、模糊逻辑、
非单调逻辑、默认逻辑、数字逻辑、电路逻辑、算法逻辑及程序逻辑等，
这些都与计算机科学密切相关.

%@see: https://www.tutorialspoint.com/discrete_mathematics/rules_of_inference.htm

\section{命题，形式语言}
\subsection{命题的概念}
\DefineConcept{命题}（proposition），
是指对确定的对象进行判断的陈述句.
这可以从两个方面去理解：\begin{enumerate}
	\item 命题必须是一个完整的句子，具有必需的语法结构（起码要有主语、谓语、宾语）；
	\item 命题必须具有真假意义，研究者应该能够判断命题是否符合客观实际或是否合理，
	这就要求命题不能是除了陈述句以外的其他句式（例如疑问句、感叹句）.
\end{enumerate}

下面几句话都是命题：\begin{itemize}
	\item 太阳总从东方升起.
	\item 只有在冬天才下雪.
	\item 水是液体.
	\item 冰是固体.
	\item 辽宁舰是中国的第一艘航空母舰.
	\item 我喜欢智能手机盒平板电脑.
	\item 小李和小王是同学.
	\item 你只有刻苦学习，才能取得好成绩.
	\item 火星上有生物\footnote{
		虽然我们至今尚不知道火星上是否存在生物，
		但我们相信在将来某个时刻一定会知道的，
		因此“火星上有生物.”是一个命题.
	}.
\end{itemize}

“\(x>3\).”不是命题，因为我们无从得知变量\(x\)的取值，进而无法确定其真假.

“立正！”是命令句，它本身没有对错之分，但命令发出后会有终结反应.

“这朵花真漂亮！”是感叹句，
“你要我的手机号码是想给我充话费？”是疑问句，
都没有真假意义.

命题的\DefineConcept{真值}（truth）就是命题的逻辑取值.
经典逻辑值只有两个：\begin{itemize}
	\item 如果命题\(p\)的判断正确，
	那么我们称“命题\(p\)是\DefineConcept{真的}（true）”，
	或称“命题\(p\)是\DefineConcept{真命题}”，
	或称“命题\(p\)的真值为\(1\)”；
	\item 如果命题\(p\)的判断错误，
	那么我们称“命题\(p\)是\DefineConcept{假的}（false）”，
	或称“命题\(p\)是\DefineConcept{假命题}”，
	或称“命题\(p\)的真值为\(0\)\footnote{
		有的书会把真命题的真值记为T，
		把假命题的真值记为F.
		还有的会把真命题的真值记为\(\top\)，
		把假命题的真值记为\(\bot\).
	}”.
\end{itemize}

\subsection{命题逻辑的形式语言}
对于用汉语（或其他人类语言）表述的命题，
我们可能会因为它含糊不清的语义而无法作出真伪判断.
因此，数学家创造了一种独立于人类语言的、专门用于逻辑演绎的语言，
这就是\DefineConcept{形式语言}（formal language）.

形式语言有三个方面可供我们讨论：\begin{enumerate}
	\item 指定形式语言使用的符号集、字母表（即下面即将介绍的命题常量、命题变元）；
	\item 制定一些规则，用以构造语法正确的有限符号串（即命题公式）；
	\item 指明形式语言与自然语言之间所允许的翻译.
\end{enumerate}

我们把用来表示命题真值的符号\(0\)和\(1\)
称为\DefineConcept{逻辑常量}或\DefineConcept{命题常量}.
相对地，把用来表示命题的小写拉丁字母（例如\(p,q,r,\dotsc\)）
称为\DefineConcept{逻辑变量}或\DefineConcept{命题变元}.
命题变元可以代表任意命题.
从取值的角度看，命题变元既可以取\(1\)也可以取\(0\).

\section{逻辑联结词，命题公式，真值表}
对于复杂的命题，我们可以将其看作是由若干个小命题组合而成的.
就像汉语中有“而且”“但是”等连接句子的虚词一样，
命题逻辑也有扮演相同角色的符号，
这就是\DefineConcept{逻辑联结词}（logical connective）.

\DefineConcept{命题公式}（proposition formula）是
由命题常量、命题变元、逻辑联结词、左圆括号、右圆括号构成的有意义的符号串，
本质上是逻辑函数或逻辑表达式，其取值只可能为\(1\)或\(0\)，
其严格定义可以借助递归定义方式给出.
\begin{definition}
%@see: 《离散数学》（邓辉文） P85 定义3-1
命题公式按下列规则生成：\begin{enumerate}[label={(\arabic*)}]
	\item 命题常量、命题变元是命题公式；
	\item 若\(A\)是命题公式，则\((\neg A)\)是命题公式；
	\item 若\(A\)和\(B\)是命题公式，则\((A \circ B)\)是命题公式，
	其中符号\(\circ\)代表某个逻辑联结词；
	\item 有限次应用(1)(2)(3)这三条规则所得到的符号串是命题公式.
\end{enumerate}
\end{definition}

我们可以按命题公式中是否含有逻辑联结词，将命题公式分为两类：\begin{itemize}
	\item \DefineConcept{简单命题}（simple proposition），
	或称\DefineConcept{原子命题}（atom proposition），
	即不含有逻辑联结词的命题公式；
	\item \DefineConcept{复合命题}（compound proposition），
	即由简单命题和逻辑联结词构成的命题公式.
\end{itemize}

\subsection{命题公式的真值表}
给定命题公式\(A\)，对\(A\)中出现的每个命题变元都指定一个真值\(1\)或\(0\)
\footnote{
	目前而言，真值集合是\(\{1,0\}\)，不含其他值.
	但是真值集合也可以是三值的，还可以是\(\mathbb{N}\)或\([0,1]\)等等.
}，
就说“对命题公式\(A\)进行了一种\DefineConcept{真值指派}（assignment）”
或者说“对命题公式\(A\)进行了一个\DefineConcept{解释}（interpretation）”，
而在该指派下可以求出命题公式\(A\)的一个真值.
将\(A\)的所有可能的真值指派以及它在每一个真值指派下的取值列成一张表，
就得到命题公式\(A\)的\DefineConcept{真值表}（truth table）.

\subsection{否定联结词}
设\(p\)表示一个命题，
\(\neg p\)是
“对命题\(p\)的\DefineConcept{否定}（negation）”，
读作“非\(p\)”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, Not[p]}, {p}] // Boole, TableHeadings -> {None, {"p", "\[Not]p"}}]
	\centering
	\begin{tabular}{|c|p{1.5cm}|}
		\hline
		\(p\) & \(\neg p\) \\
		\hline
		0 & 1 \\
		1 & 0 \\
		\hline
	\end{tabular}
	\caption{否定联结词的真值表}
\end{table}

\(\neg\)是仅有的一个一元逻辑运算符，
下面讨论的都是二元逻辑运算符.

\subsection{合取联结词}
设\(p,q\)各表示一个命题，
\(p \land q\)是
“对命题\(p\)与\(q\)的\DefineConcept{合取}（conjunction）”.

合取联结词\(\land\)相当于汉语中的
“并且”“与”“和”“以及”“不但……而且……”
“虽然……但是……”“尽管……仍然……”等.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, And[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[And] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \land q\) \\
		\hline
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		1 & 0 & 0 \\
		1 & 1 & 1 \\
		\hline
	\end{tabular}
	\caption{合取联结词的真值表}
\end{table}

\subsection{析取联结词}
设\(p,q\)各表示一个命题，
\(p \lor q\)是
“对命题\(p\)与\(q\)的\DefineConcept{析取}（disjunction）”.

析取联结词\(\lor\)相当于汉语中的“或”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Or[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Or] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \lor q\) \\
		\hline
		0 & 0 & 0 \\
		0 & 1 & 1 \\
		1 & 0 & 1 \\
		1 & 1 & 1 \\
		\hline
	\end{tabular}
	\caption{析取联结词的真值表}
\end{table}

\subsection{异或联结词}
设\(p,q\)各表示一个命题，
\(p \lxor q\)是
“对命题\(p\)与\(q\)的\DefineConcept{异或}（exclusive or）”.

为了凸出析取联结词与异或联结词的联系与区别，
我们常把对命题\(p\)与\(q\)的析取\(p \lor q\)
称为“对\(p\)与\(q\)的\DefineConcept{可兼或}（inclusive or）”，
把对\(p\)与\(q\)的异或\(p \lxor q\)
称为“对\(p\)与\(q\)的\DefineConcept{不可兼或}”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Xor[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Xor] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \lxor q\) \\
		\hline
		0 & 0 & 0 \\
		0 & 1 & 1 \\
		1 & 0 & 1 \\
		1 & 1 & 0 \\
		\hline
	\end{tabular}
	\caption{异或联结词的真值表}
\end{table}

\subsection{条件联结词}
%@see: https://plato.stanford.edu/entries/necessary-sufficient/
设\(p,q\)各表示一个命题，
\(p \limp q\)读作“\(p\)蕴含\(q\)”或“\(p\)条件\(q\)”.

我们把\(p\)称为“\(p \limp q\)的\DefineConcept{前件}（antecedent）”
或“\(p \limp q\)的\DefineConcept{条件}（premise）”，
把\(q\)称为“\(p \limp q\)的\DefineConcept{后件}（consequent）”
或“\(p \limp q\)的\DefineConcept{结论}（conclusion）”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Implies[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Implies] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \limp q\) \\
		\hline
		0 & 0 & 1 \\
		0 & 1 & 1 \\
		1 & 0 & 0 \\
		1 & 1 & 1 \\
		\hline
	\end{tabular}
	\caption{条件联结词的真值表}
\end{table}

如果已知命题\(p \limp q\)是真命题，
则称“\(p\)是\(q\)的一个\DefineConcept{充分条件}（sufficient condition）”，
或称“\(q\)是\(p\)的一个\DefineConcept{必要条件}（necessary condition）”.

如果已知\((p \limp q)\)和\((q \limp p)\)都是真命题，
则称“\(p\)是\(q\)的一个\DefineConcept{充分必要条件}”，
或称“\(q\)是\(p\)的一个\DefineConcept{充分必要条件}”.

如果已知\((p \limp q)\)是真命题而\((q \limp p)\)是假命题，
则称“\(p\)是\(q\)的一个\DefineConcept{充分不必要条件}”，
或称“\(q\)是\(p\)的一个\DefineConcept{必要不充分条件}”.

把\(q \limp p\)称为“\(p \limp q\)的\DefineConcept{逆命题}”.
称“\(q \limp p\)和\(p \limp q\)是\DefineConcept{互逆命题}”.

把\(\neg p \limp \neg q\)称为“\(p \limp q\)的\DefineConcept{否命题}”.
称“\(\neg p \limp \neg q\)和\(p \limp q\)是\DefineConcept{互否命题}”.

把\(\neg q \limp \neg p\)称为“\(p \limp q\)的\DefineConcept{逆否命题}”.
称“\(\neg q \limp \neg p\)和\(p \limp q\) \DefineConcept{互为逆否命题}”.

\begin{figure}[htb]
	\centering
	\tikzstyle{prop} = [rectangle, minimum width=3cm, minimum height=2cm, text centered, draw=black, fill=orange!30]
	\tikzstyle{arrow} = [thick,<->,>=stealth]
	\begin{tikzpicture}[node distance=4cm]
		\node (p11) [prop] {\begin{tblr}{c}
			原命题 \\ \(p \limp q\)
		\end{tblr}};
		\node (p12) [prop, right=6cm of p11] {\begin{tblr}{c}
			逆命题 \\ \(q \limp p\)
		\end{tblr}};
		\node (p21) [prop, below of=p11] {\begin{tblr}{c}
			否命题 \\ \(\neg p \limp \neg q\)
		\end{tblr}};
		\node (p22) [prop, below of=p12] {\begin{tblr}{c}
			逆否命题 \\ \(\neg q \limp \neg p\)
		\end{tblr}};

		\begin{scope}[arrow]
			\draw (p11) -- node[anchor=south]{互逆} (p12);
			\draw (p11) -- node[anchor=east]{互否} (p21);
			\draw (p22) -- node[anchor=north]{互逆} (p21);
			\draw (p22) -- node[anchor=west]{互否} (p12);
			\draw (p11) -- node[sloped,near end,below]{互为逆否} (p22);
			\draw (p12) -- node[sloped,near end,above]{互为逆否} (p21);
		\end{scope}
	\end{tikzpicture}
	\caption{}
\end{figure}

\subsection{等价联结词}
设\(p,q\)各表示一个命题，
\(p \liff q\)读作“\(p\)等价\(q\)”或“\(p\)双条件\(q\)”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Equivalent[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Equivalent] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \liff q\) \\
		\hline
		0 & 0 & 1 \\
		0 & 1 & 0 \\
		1 & 0 & 0 \\
		1 & 1 & 1 \\
		\hline
	\end{tabular}
	\caption{等价联结词的真值表}
\end{table}

\subsection{与非联结词}
设\(p,q\)各表示一个命题，
\(p \lnand q\)读作“\(p\)与非\(q\)”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Nand[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Nand] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \lnand q\) \\
		\hline
		0 & 0 & 1 \\
		0 & 1 & 1 \\
		1 & 0 & 1 \\
		1 & 1 & 0 \\
		\hline
	\end{tabular}
	\caption{与非联结词的真值表}
\end{table}

\subsection{或非联结词}
设\(p,q\)各表示一个命题，
\(p \lnor q\)读作“\(p\)或非\(q\)”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Nor[p, q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Nor] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \lnor q\) \\
		\hline
		0 & 0 & 1 \\
		0 & 1 & 0 \\
		1 & 0 & 0 \\
		1 & 1 & 0 \\
		\hline
	\end{tabular}
	\caption{或非联结词的真值表}
\end{table}

\subsection{条件否定联结词}
设\(p,q\)各表示一个命题，
\(p \lnimp q\)读作“\(p\)条件否定\(q\)”.

\begin{table}[ht]
%@Mathematica: TableForm[BooleanTable[{p, q, Not[Implies[p, q]]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p !\[Implies] q"}}]
	\centering
	\begin{tabular}{|*{2}{c|}p{2cm}|}
		\hline
		\(p\) & \(q\) & \(p \lnimp q\) \\
		\hline
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		1 & 0 & 1 \\
		1 & 1 & 0 \\
		\hline
	\end{tabular}
	\caption{条件否定联结词的真值表}
\end{table}

\subsection{括号的省略}
我们解读形式语言的顺序和汉语、英语等常见人类语言一致.
除非命题公式有括号，否则我们总是按照从左到右的顺序，分析理解形式语言的含义.

严格按照命题公式的定义，就会出现很多的括号.
一方面，这些括号使得命题公式的结构清晰、含义清除；
而另一方面，括号太多给命题公式的阅读和书写带来不便.
因此，为了简化书写，减少命题公式中括号的数目，特作如下一些可以省略括号的约定：\begin{itemize}
	\item 最外层的括号可以省略；
	\item 9个逻辑联结词运算的优先顺序依次为\footnote{
		有的书上只规定了\(\neg,\land,\lor,\limp,\liff\)这5个逻辑联结词的优先顺序.
	}\begin{equation*}
		\neg, \quad
		\land, \quad
		\lor, \quad
		\lxor, \quad
		\limp, \quad
		\liff, \quad
		\lnand, \quad
		\lnor, \quad
		\lnimp,
	\end{equation*}
	符合本约定的有些括号可以不写（详见\cref{definition:命题逻辑.逻辑联结词的优先顺序}）；
	\item 同级运算从右往左依次进行
	\footnote{
		有的书上规定同级运算从左往右依次进行.
		以后我们会证明，
		当改变运算顺序时，
		\(\land,\lor,\lxor,\liff\)的运算结果不变，
		\(\limp,\lnand,\lnor\)的运算结果改变.
	}.
\end{itemize}

\begin{definition}\label{definition:命题逻辑.逻辑联结词的优先顺序}
设\(\phi,\psi,\eta\)都是命题公式.
定义：\begin{gather}
	\phi
	\defiff
	(\phi), \\
	(\neg\phi\land\psi)
	\defiff
	((\neg\phi)\land\psi), \\
	(\phi\land\neg\psi)
	\defiff
	(\phi\land(\neg\psi)), \\
	(\neg\phi\lor\psi)
	\defiff
	((\neg\phi)\lor\psi), \\
	(\phi\lor\neg\psi)
	\defiff
	(\phi\lor(\neg\psi)), \\
	(\neg\phi\limp\psi)
	\defiff
	((\neg\phi)\limp\psi), \\
	(\phi\limp\neg\psi)
	\defiff
	(\phi\limp(\neg\psi)), \\
	(\neg\phi\liff\psi)
	\defiff
	((\neg\phi)\liff\psi), \\
	(\phi\liff\neg\psi)
	\defiff
	(\phi\liff(\neg\psi)), \\
	(\phi\land\psi\land\eta)
	\defiff
	(\phi\land(\psi\land\eta)), \\
	(\phi\land\psi\lor\eta)
	\defiff
	((\phi\land\psi)\lor\eta), \\
	(\phi\lor\psi\lor\eta)
	\defiff
	(\phi\lor(\psi\lor\eta)), \\
	(\phi\lor\psi\land\eta)
	\defiff
	(\phi\lor(\psi\land\eta)), \\
	(\phi\land\psi\limp\eta)
	\defiff
	((\phi\land\psi)\limp\eta), \\
	(\phi\limp\psi\limp\eta)
	\defiff
	(\phi\limp(\psi\limp\eta)), \\
	(\phi\limp\psi\land\eta)
	\defiff
	(\phi\limp(\psi\land\eta)), \\
	(\phi\land\psi\liff\eta)
	\defiff
	((\phi\land\psi)\liff\eta), \\
	(\phi\liff\psi\liff\eta)
	\defiff
	(\phi\liff(\psi\liff\eta)), \\
	(\phi\liff\psi\land\eta)
	\defiff
	(\phi\liff(\psi\land\eta)), \\
	(\phi\lor\psi\limp\eta)
	\defiff
	((\phi\lor\psi)\limp\eta), \\
	(\phi\limp\psi\lor\eta)
	\defiff
	(\phi\limp(\psi\lor\eta)), \\
	(\phi\lor\psi\liff\eta)
	\defiff
	((\phi\lor\psi)\liff\eta), \\
	(\phi\liff\psi\lor\eta)
	\defiff
	(\phi\liff(\psi\lor\eta)), \\
	(\phi\limp\psi\liff\eta)
	\defiff
	((\phi\limp\psi)\liff\eta), \\
	(\phi\liff\psi\limp\eta)
	\defiff
	(\phi\liff(\psi\limp\eta)).
\end{gather}
\end{definition}

% \begin{definition}
% 设\(\phi,\psi\)都是合式公式.
% 定义：
% \((\neg(\phi\limp\psi))
% \defiff
% (\phi\lnimp\psi)\).
% \end{definition}

\begin{example}
\([(\neg p) \lor (q)]\)等同于\([\neg p \lor q]\).
\end{example}

\begin{example}
\([p \limp q \land r \limp s]\)等同于\([(p \limp (q \land r)) \limp s]\).
\end{example}

\subsection{命题公式的类型}
\begin{definition}
%@see: 《离散数学》（邓辉文） P88 定义3-2
在任何指派下均取真的命题公式，
称为\DefineConcept{永真式}或\DefineConcept{重言式}（tautology）.
\end{definition}

\begin{definition}
%@see: 《离散数学》（邓辉文） P88 定义3-2
在任何指派下均取假的命题公式，
称为\DefineConcept{永假式}或\DefineConcept{矛盾式}（contradiction）.
\end{definition}

\begin{definition}
%@see: 《离散数学》（邓辉文） P88 定义3-2
至少有一种指派使其为真的命题公式，
称为\DefineConcept{可满足式}（satisfactable formula）.
\end{definition}

\begin{definition}
%@see: 《离散数学》（邓辉文） P88 定义3-2
至少有一种指派使其为真，同时至少有一种指派使其为假的命题公式，
称为\DefineConcept{中性式}或\DefineConcept{偶然式}（contingency）.
\end{definition}

\begin{example}
命题公式\(\neg p \lor q \limp r\)是中性式.
\end{example}

\begin{example}
命题公式\(p \lor \neg p\)是永真式.
\end{example}

\begin{example}
命题公式\(p \land \neg p\)是永假式.
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P89 例3-9
证明：命题公式\((p \limp q) \liff (\neg p \lor q)\)是永真式.
\begin{proof}
列出\((p \limp q) \liff (\neg p \lor q)\)的真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, Implies[p, q], Not[p], Or[Not[p], q], Equivalent[Implies[p, q], Or[Not[p], q]]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Implies] q", "\[Not]p", "\[Not]p\[Or]q", "(p\[Implies]q)\[Equivalent](\[Not]p\[Or]q)"}}]
	\begin{tblr}{*2c|*3c|c}
		\hline
		\(p\) & \(q\) & \(p \limp q\) & \(\neg p\) & \(\neg p \lor q\) & \((p \limp q) \liff (\neg p \lor q)\) \\
		\hline
		1 & 1 & 1 & 0 & 1 & 1 \\
		1 & 0 & 0 & 0 & 0 & 1 \\
		0 & 1 & 1 & 1 & 1 & 1 \\
		0 & 0 & 1 & 1 & 1 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可知，命题公式\((p \limp q) \liff (\neg p \lor q)\)是永真式.
\end{proof}
\end{example}
\begin{remark}
像这样，通过绘制真值表，得出一个命题公式的类型的方法，称为\emph{真值表法}.
真值表法是最常用的判断命题公式类型的方法，
但是话说回来，当命题变元较多时，真值表法是极为不方便的.
\end{remark}

\begin{example}
%@see: 《离散数学》（邓辉文） P89 例3-10
证明：命题公式\((p \land (p \limp q)) \limp q\)是永真式.
\begin{proof}
假设\(p \land (p \limp q)\)取真，
则\(p\)及\(p \limp q\)均取真，
进而\(q\)为真，
因此\((p \land (p \limp q)) \limp q\)永真.
\end{proof}
\end{example}
\begin{remark}
像这样，利用对取值进行分析，得出一个命题公式的类型的方法，称为\emph{取值法}.
\end{remark}

\begin{example}
证明：命题公式\(p \limp p\)是永真式.
% 同一律
\begin{proof}
列出\(p \limp p\)的真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, Implies[p, p]}, p] // Boole, TableHeadings -> {None, {"p", "p \[Implies] p"}}]
	\begin{tblr}{c|c}
		\hline
		\(p\) & \(p \limp p\) \\
		\hline
		1 & 1 \\
		0 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可知，命题公式\(p \limp p\)是永真式.
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P90 习题 4.(1)
证明：命题公式\(p \limp (q \limp p)\)是永真式.
% 肯定后件律
\begin{proof}
列出\(p \limp (q \limp p)\)的真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, Implies[q, p], Implies[p, Implies[q, p]]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "q \[Implies] p", "p\[Implies](q \[Implies] p)"}}]
	\begin{tblr}{*2c|c|c}
		\hline
		\(p\) & \(q\) & \(q \limp p\) & \(p \limp (q \limp p)\) \\
		\hline
		1 & 1 & 1 & 1 \\
		1 & 0 & 1 & 1 \\
		0 & 1 & 0 & 1 \\
		0 & 0 & 1 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可知，命题公式\(p \limp (q \limp p)\)是永真式.
\end{proof}
\end{example}

\begin{example}
证明：命题公式\((p \limp (q \limp r)) \limp ((p \limp q) \limp (p \limp r))\)是永真式.
\begin{proof}
列出\((p \limp (q \limp r)) \limp ((p \limp q) \limp (p \limp r))\)的真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, r, Implies[Implies[p, Implies[q, r]], Implies[Implies[p, q], Implies[p, r]]]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "(p\[Implies](q\[Implies]r))\[Implies]((p\[Implies]q)\[Implies](p\\[Implies]r))"}}]
	\begin{tblr}{*3c|c}
		\hline
		\(p\) & \(q\) & \(r\) & \((p \limp (q \limp r)) \limp ((p \limp q) \limp (p \limp r))\) \\
		\hline
		1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 1 \\
		1 & 0 & 1 & 1 \\
		1 & 0 & 0 & 1 \\
		0 & 1 & 1 & 1 \\
		0 & 1 & 0 & 1 \\
		0 & 0 & 1 & 1 \\
		0 & 0 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可知，命题公式\((p \limp (q \limp r)) \limp ((p \limp q) \limp (p \limp r))\)是永真式.
\end{proof}
\end{example}

\begin{example}
证明：命题公式\((\neg p \limp \neg q) \limp (q \limp p)\)是永真式.
\begin{proof}
列出\((\neg p \limp \neg q) \limp (q \limp p)\)的真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, Implies[Implies[Not[p], Not[q]], Implies[q, p]]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "(\[Not]p\[Implies]\[Not]q)\[Implies](q\[Implies]p)"}}]
	\begin{tblr}{*2c|c}
		\hline
		\(p\) & \(q\) & \((\neg p \limp \neg q) \limp (q \limp p)\) \\
		\hline
		1 & 1 & 1 \\
		1 & 0 & 1 \\
		0 & 1 & 1 \\
		0 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可知，命题公式\((\neg p \limp \neg q) \limp (q \limp p)\)是永真式.
\end{proof}
\end{example}

下面介绍\DefineConcept{永真式代入定理}（Rule of Substitution，简称RS）.
\begin{theorem}
%@see: 《离散数学》（邓辉文） P89 定理3-1
设命题公式\(A(\AutoTuple{p}{n})\)是永真式，
则分别用命题公式\(\AutoTuple{B}{n}\)代换命题变元\(\AutoTuple{p}{n}\)，
所得到的命题公式\(A(\AutoTuple{B}{n})\)也是永真式.
%TODO proof
\end{theorem}
% \DefineConcept{代入实例}（substitution instance）

\section{逻辑等值的命题公式}
\subsection{逻辑等值的定义}
\begin{definition}
%@see: 《离散数学》（邓辉文） P90 定义3-3
给定两个命题公式\(A\)和\(B\)，
如果在任何真值指派下，\(A\)和\(B\)的真值都相同，
则称“命题公式\(A\)和\(B\) \DefineConcept{逻辑等值}（logically equal）”
或“命题公式\(A\)和\(B\) \DefineConcept{逻辑等价}（logically equivalent）”，
记为\(A = B\).
反之，如果在某个真值指派下，\(A\)和\(B\)的真值不同，
则记\(A \neq B\).
\end{definition}
\begin{remark}
注意不要混淆“逻辑等价”与“等价联结词”这两个概念.
\end{remark}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P91 定理3-2
设\(A\)和\(B\)是命题公式，
则\(A = B\)的充分必要条件是\(A \liff B\)是永真式.
%TODO proof
\end{theorem}

\begin{example}
%@see: 《离散数学》（邓辉文） P91 例3-11
证明：对于任意命题公式\(p,q\)，
有\begin{equation}\label{equation:数理逻辑.蕴含式化为析取式}
	p \limp q = \neg p \lor q.
\end{equation}
\begin{proof}
列出真值表：\begin{center}
	\begin{tblr}{*5c}
		\hline
		\(p\) & \(q\) & \(p \limp q\) & \(\neg p\) & \(\neg p \lor q\) \\
		\hline
		0 & 0 & 1 & 1 & 1 \\
		0 & 1 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 & 0 \\
		1 & 1 & 1 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
显然有\(p \limp q = \neg p \lor q\).
\end{proof}
\end{example}

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation}
	(p \limp r) \land (q \limp r) = (p \lor q) \limp r.
\end{equation}
%@Mathematica: TableForm[BooleanTable[{p, q, r, And[Implies[p, r], Implies[q, r]], Implies[Or[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "(p\[Implies]r)\[And](q\[Implies]r)", "(p\[Or]q)\[Implies]r"}}]
\begin{proof}
列出真值表：\begin{center}
	\begin{tblr}{*5c}
		\hline
		\(p\) & \(q\) & \(r\)
		& \((p \limp r) \land (q \limp r)\)
		& \((p \lor q) \limp r\) \\ \hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 & 0 \\
		0 & 1 & 1 & 1 & 1 \\
		0 & 1 & 0 & 0 & 0 \\
		0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 0 & 1 & 1 \\
		\hline
	\end{tblr}
\end{center}
显然有\((p \limp r) \land (q \limp r) = (p \lor q) \limp r\).
\end{proof}
\end{example}

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation}
	(p \limp q) \land (p \limp r) = p \limp (q \land r).
\end{equation}
%@Mathematica: TableForm[BooleanTable[{p, q, r, And[Implies[p, q], Implies[p, r]], Implies[p, And[q, r]]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "(p\[Implies]q)\[And](p\[Implies]r)", "p\[Implies](q\[And]r)"}}]
\begin{proof}
列出真值表：\begin{center}
	\begin{tblr}{*5c}
		\hline
		\(p\) & \(q\) & \(r\)
		& \((p \limp q) \land (p \limp r)\)
		& \(p \limp (q \land r)\) \\ \hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 0 & 0 & 0 \\
		0 & 1 & 1 & 1 & 1 \\
		0 & 1 & 0 & 1 & 1 \\
		0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 0 & 1 & 1 \\
		\hline
	\end{tblr}
\end{center}
显然有\((p \limp q) \land (p \limp r) = p \limp (q \land r)\).
\end{proof}
\end{example}

%@Mathematica: TableForm[BooleanTable[{p, q, r, And[p, And[q, r]], And[And[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[And](q\[And]r)", "(p\[And]q)\[And]r"}}]
%@Mathematica: TableForm[BooleanTable[{p, q, r, Or[p, Or[q, r]], Or[Or[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Or](q\[Or]r)", "(p\[Or]q)\[Or]r"}}]
%@Mathematica: TableForm[BooleanTable[{p, q, r, Xor[p, Xor[q, r]], Xor[Xor[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Xor](q\[Xor]r)", "(p\[Xor]q)\[Xor]r"}}]

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation*}
	p \limp (q \limp r)
	\neq
	(p \limp q) \limp r.
\end{equation*}
\begin{proof}
列出真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, r, Implies[p, Implies[q, r]], Implies[Implies[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Equivalent](q\[Equivalent]r)", "(p\[Equivalent]q)\[Equivalent]r"}}]
	\begin{tblr}{*3c|cc}
		\hline
		\(p\) & \(q\) & \(r\)
		& \(p \limp (q \limp r)\)
		& \((p \limp q) \limp r\) \\ \hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 1 & 1 \\
		0 & 1 & 1 & 1 & 1 \\
		0 & 1 & 0 & 1 & 0 \\
		0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 0 & 1 & 0 \\
		\hline
	\end{tblr}
\end{center}
显然有\(p \limp (q \limp r) \neq (p \limp q) \limp r\).
\end{proof}
\end{example}

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation*}
	p \liff (q \liff r)
	= (p \liff q) \liff r.
\end{equation*}
\begin{proof}
列出真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, r, Equivalent[p, Equivalent[q, r]], Equivalent[Equivalent[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Equivalent](q\[Equivalent]r)", "(p\[Equivalent]q)\[Equivalent]r"}}]
	\begin{tblr}{*3c|cc}
		\hline
		\(p\) & \(q\) & \(r\)
		& \(p \liff (q \liff r)\)
		& \((p \liff q) \liff r\) \\ \hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 0 & 1 & 1 \\
		0 & 1 & 1 & 0 & 0 \\
		0 & 1 & 0 & 1 & 1 \\
		0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 0 & 0 & 0 \\
		\hline
	\end{tblr}
\end{center}
显然有\(p \liff (q \liff r) = (p \liff q) \liff r\).
\end{proof}
\end{example}

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation*}
	p \lnand (q \lnand r)
	\neq
	(p \lnand q) \lnand r.
\end{equation*}
\begin{proof}
列出真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, r, Nand[p, Nand[q, r]], Nand[Nand[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Nand](q\[Nand]r)", "(p\[Nand]q)\[Nand]r"}}]
	\begin{tblr}{*3c|cc}
		\hline
		\(p\) & \(q\) & \(r\)
		& \(p \lnand (q \lnand r)\)
		& \((p \lnand q) \lnand r\) \\ \hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 1 & 0 & 0 & 1 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 0 & 0 & 1 \\
		0 & 1 & 1 & 1 & 0 \\
		0 & 1 & 0 & 1 & 1 \\
		0 & 0 & 1 & 1 & 0 \\
		0 & 0 & 0 & 1 & 1 \\
		\hline
	\end{tblr}
\end{center}
显然有\(p \lnand (q \lnand r) \neq (p \lnand q) \lnand r\).
\end{proof}
\end{example}

\begin{example}
证明：对于任意命题公式\(p,q,r\)，有\begin{equation*}
	p \lnor (q \lnor r)
	\neq
	(p \lnor q) \lnor r.
\end{equation*}
\begin{proof}
列出真值表：\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, r, Nor[p, Nor[q, r]], Nor[Nor[p, q], r]}, {p, q, r}] // Boole, TableHeadings -> {None, {"p", "q", "r", "p\[Nor](q\[Nor]r)", "(p\[Nor]q)\[Nor]r"}}]
	\begin{tblr}{*3c|cc}
		\hline
		\(p\) & \(q\) & \(r\)
		& \(p \lnor (q \lnor r)\)
		& \((p \lnor q) \lnor r\) \\ \hline
		1 & 1 & 1 & 0 & 0 \\
		1 & 1 & 0 & 0 & 1 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 0 & 0 & 1 \\
		0 & 1 & 1 & 1 & 0 \\
		0 & 1 & 0 & 1 & 1 \\
		0 & 0 & 1 & 1 & 0 \\
		0 & 0 & 0 & 0 & 0 \\
		\hline
	\end{tblr}
\end{center}
显然有\(p \lnor (q \lnor r) \neq (p \lnor q) \lnor r\).
\end{proof}
\end{example}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P91 定理3-3
设\(A_1(\AutoTuple{p}{n}) = A_2(\AutoTuple{p}{n})\).
分别用命题公式\(\AutoTuple{B}{n}\)代换命题变元\(\AutoTuple{p}{n}\)，
所得到的两个命题公式等值，即\begin{equation*}
	A_1(\AutoTuple{B}{n}) = A_2(\AutoTuple{B}{n}).
\end{equation*}
%TODO proof
\end{theorem}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P91 定理3-4
对于任意命题公式\(A,B,C\)，有\begin{itemize}
	\item {\rm\bf 自反性}：\(A = A\).
	\item {\rm\bf 对称性}：若\(A = B\)，则\(B = A\).
	\item {\rm\bf 传递性}：若\(A = B\)且\(B = C\)，则\(A = C\).
\end{itemize}
%TODO proof
\end{theorem}

\subsection{基本等值式}
\begin{theorem}\label{theorem:数理逻辑.基本等值式}
%@see: 《离散数学》（邓辉文） P91 定理3-5
对于任意命题公式\(A,B,C\)，
有\begin{itemize}
	\item {\rm\bf 对合律}：\begin{equation}
		% 双重否定律
		\neg\neg A = A.
	\end{equation}

	\item {\rm\bf 幂等律}（或称{\rm\bf 重叠律}）：\begin{gather}
		A \lor A = A, \\
		A \land A = A.
	\end{gather}

	\item {\rm\bf 交换律}：\begin{gather}
		A \lor B = B \lor A, \\
		A \land B = B \land A.
	\end{gather}

	\item {\rm\bf 结合律}：\begin{gather}
		(A \lor B) \lor C = A \lor (B \lor C), \\
		(A \land B) \land C = A \land (B \land C).
	\end{gather}

	\item {\rm\bf 吸收律}：\begin{gather}
		A \lor (A \land B) = A, \\
		A \land (A \lor B) = A.
	\end{gather}

	\item {\rm\bf 分配律}：\begin{gather}
		A \lor (B \land C) = (A \lor B) \land (A \lor C), \\
		A \land (B \lor C) = (A \land B) \lor (A \land C).
	\end{gather}

	\item {\rm\bf 互补律}：\begin{gather}
		% 排中律
		A \lor \neg A = 1, \\
		% 矛盾律
		A \land \neg A = 0.
	\end{gather}

	\item {\rm\bf 德摩根律}：\begin{gather}
		\neg(A \lor B) = \neg A \land \neg B, \\
		\neg(A \land B) = \neg A \lor \neg B.
	\end{gather}

	\item {\rm\bf 同一律}：\begin{gather}
		A \lor 0 = 0 \lor A = A, \\
		A \land 1 = 1 \land A = A.
	\end{gather}

	\item {\rm\bf 0-1 律}：\begin{gather}
		A \lor 1 = 1 \lor A = 1, \\
		A \land 0 = 0 \land A = 0.
	\end{gather}
\end{itemize}
\end{theorem}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P92 定理3-6
对于任意命题公式\(A,B\)，有\begin{gather}
	A \lxor B
	= \neg(A \liff B),
		\label{equation:数理逻辑.联结词等值式1} \\
	A \limp B
	= \neg A \lor B,
		\label{equation:数理逻辑.联结词等值式2} \\
	A \liff B
	= (A \limp B) \land (B \limp A),
		\label{equation:数理逻辑.联结词等值式3} \\
	A \lnand B
	= \neg(A \land B),
		\label{equation:数理逻辑.联结词等值式4} \\
	A \lnor B
	= \neg(A \lor B),
		\label{equation:数理逻辑.联结词等值式5} \\
	A \lnimp B
	= \neg(A \limp B).
		\label{equation:数理逻辑.联结词等值式6}
\end{gather}
\end{theorem}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P94 习题3.4 5.
%@see: 《离散数学》（邓辉文） P94 习题3.4 6.
对于任意命题公式\(A,B,C\)，有\begin{gather}
	A \lxor B = B \lxor A, \\
	(A \lxor B) \lxor C = A \lxor (B \lxor C), \\
	A \limp B = \neg B \limp \neg A, \\
	\neg(A \liff B) = A \liff \neg B, \\
	\neg A = A \lnand A, \\
	\neg A = A \lnor A, \\
	A \land B = (A \lnand B) \lnand (A \lnand B), \\
	A \land B = (A \lnor A) \lnor (B \lnor B), \\
	A \lor B = (A \lnand A) \lnand (B \lnand B), \\
	A \lor B = (A \lnor B) \lnor (A \lnor B), \\
	A \liff B = B \liff A, \\
	(A \liff B) \liff C = A \liff (B \liff C), \\
	A \liff B = \neg(A \lxor B), \\
	A \liff B = (A \land B) \lor (\neg A \land \neg B).
\end{gather}
\end{theorem}

\subsection{等值演算法}
基本等值式有很多用途，
可以用于化简命题公式（即将命题公式化为一个与其等值的满足指定条件的含联结词最少的命题公式）、
判断命题公式的类型、证明等值式、计算命题公式的范式、命题逻辑推理等.

在使用等值式时，下列\DefineConcept{等值置换定理}（Rule of Replacement，简称RR）是至关重要的.
\begin{theorem}
设\(C\)是命题公式\(A\)的子公式，且\(C = D\)，
则将\(A\)中的\(C\)部分或全部替换成\(D\)所得到的命题公式与\(A\)等值.
%TODO proof
\end{theorem}

利用基本等值式和等值置换定理求解问题的方法称为\emph{等值演算法}.

\begin{example}
%@see: 《离散数学》（邓辉文） P93 例3-13(1)
设\(A,B,C\)是任意的命题公式，
化简命题公式\((A \limp (B \lor \neg C)) \land \neg A \land B\)，
将最后结果表示为只含\(\neg\)和\(\lor\)的命题公式.
\begin{solution}
直接计算得\begin{align*}
	(A \limp (B \lor \neg C)) \land \neg A \land B
	&= (\neg A \lor (B \lor \neg C)) \land \neg A \land B \\
	&= ((\neg A \lor (B \lor \neg C)) \land \neg A) \land B \\
	% 吸收律
	&= \neg A \land B
	= \neg(A \lor \neg B).
\end{align*}
\end{solution}
\end{example}

\subsection{对偶原理}
在\cref{theorem:数理逻辑.基本等值式} 中，
除了对合律以外，其他性质都是成对出现的，两者间有一定的联系.
下面我们给出命题公式的对偶式的定义.
\begin{definition}
%@see: 《离散数学》（邓辉文） P94 定义3-4
设命题公式\(A\)中至多含有3个逻辑联结词\(\neg,\land,\lor\).
将\(A\)中\(\land\)换成\(\lor\)，\(\lor\)换成\(\land\)，\(1\)换成\(0\)，\(0\)换成\(1\)，
所得到的命题公式称为“\(A\)的\DefineConcept{对偶式}（dual formula）”，记为\(A^*\).
\end{definition}

\begin{example}
%@see: 《离散数学》（邓辉文） P94 例3-16(1)
设\(p,q\)是命题变元，写出命题公式\(\neg(p \land q) \land 1\)的对偶式.
\begin{solution}
命题公式\(\neg(p \land q) \land 1\)的对偶式为
\(\neg(p \lor q) \lor 0\).
\end{solution}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P94 例3-16(2)
设\(p,q,r\)是命题变元，写出命题公式\(p \lor (q \land r)\)的对偶式.
\begin{solution}
命题公式\(p \lor (q \land r)\)的对偶式为
\(p \land (q \lor r)\).
\end{solution}
\end{example}

\begin{theorem}[对偶原理]
%@see: 《离散数学》（邓辉文） P94 定理3-8（对偶原理）
设\(A\)和\(B\)是命题公式.
若\(A = B\)，则\(A^* = B^*\).
\begin{proof}
利用德摩根律易证.
\end{proof}
\end{theorem}

对偶原理有利于记忆\cref{theorem:数理逻辑.基本等值式}，
这是因为除了对合律以外的其余每一对性质，都只需要记住其中一个即可.

\section{命题公式的范式}
%@see: https://www.geeksforgeeks.org/normal-and-principle-forms/
%@see: https://library.fiveable.me/key-terms/formal-logic-ii/conjunctive-normal-form
给定一个命题公式，根据它的真值表，显然可以方便地得出它在每一种指派下的真值.
但是随着命题变元个数\(N\)的增加，命题公式的真值指派就有\(2^N\)种，在实际计算中就变成不可行的了.

\begin{definition}
设\(A\)是命题公式.
若\begin{equation*}
	A = A_1 \lor A_2 \lor \dotsb \lor A_n
	\quad(n\geq1),
\end{equation*}
其中\(A_i\ (i=1,2,\dotsc,n)\)是由命题变元或其否定组成的合取式，
则称“\(A_1 \lor A_2 \lor \dotsb \lor A_n\)是
\(A\)的\DefineConcept{析取范式}（disjunctive normal form）”.
\end{definition}

\begin{definition}
设\(A\)是命题公式.
若\begin{equation*}
	A = A_1 \land A_2 \land \dotsb \land A_n
	\quad(n\geq1),
\end{equation*}
其中\(A_i\ (i=1,2,\dotsc,n)\)是由命题变元或其否定组成的析取式，
则称“\(A_1 \land A_2 \land \dotsb \land A_n\)是
\(A\)的\DefineConcept{合取范式}（conjunctive normal form）”.
\end{definition}

可以证明：任意一个命题公式都存在析取范式与合取范式.

计算析取范式、合取范式的步骤：\begin{enumerate}
	\item 使用等值式，将命题公式中的联结词归约为\(\neg,\land,\lor\)；
	\item 利用德摩根律，将\(\neg\)移到命题变元的前面；
	\item 根据分配律，得到命题公式的析取范式、合取范式.
\end{enumerate}

\begin{example}
设\(p,q,r\)都是命题变元.
求命题公式\(A = p \limp q \liff r\)的析取范式、合取范式.
\begin{solution}
由等值式得\begin{align*}
	A &= p \limp q \liff r \\
	&= (\neg p \lor q \limp r) \land (r \limp \neg p \lor q) \\
	&= (\neg(\neg p \lor q) \lor r) \land (\neg r \lor (\neg p \lor q)) \\
	&= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r).
\end{align*}
于是\(A\)的析取范式为\begin{align*}
	A &= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \land \neg q) \land (\neg p \lor q \lor \neg r)
		\lor r \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \land \neg q) \land \neg p
		\lor (p \land \neg q) \land q
		\lor (p \land \neg q) \land \neg r
		\lor r \land \neg p
		\lor r \land q
		\lor r \land \neg r \\
	% 吸收律，消去\(p \land \neg p\)、\(q \land \neg q\)和\(r \land \neg r\)
	&= p \land \neg q \land \neg r
		\lor \neg p \land r
		\lor q \land r,
\end{align*}
\(A\)的合取范式为\begin{align*}
	A &= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \lor r) \land (\neg q \lor r) \land (\neg p \lor q \lor \neg r).
\end{align*}
\end{solution}
\end{example}

根据命题公式的析取范式、合取范式，可以分别得出该命题公式的成真指派、成假指派.
例如，已知\(A\)的析取范式是
\(A = p \land \neg q \land \neg r
\lor \neg p \land r
\lor q \land r\)，
若要\(A\)取\(1\)，
则\begin{equation*}
	p \land \neg q \land \neg r,
	\qquad
	\neg p \land r
	\qquad
	q \land r
\end{equation*}至少一个为\(1\)，
由\(p \land \neg q \land \neg r = 1\)得\((p,q,r) = (1,0,0)\)，
由\(\neg p \land r = 1\)得\((p,q,r) = (0,1,1),(0,0,1)\)，
由\(q \land r = 1\)得\((p,q,r) = (1,1,1),(0,1,1)\)，
于是，\(A\)的成真指派有\begin{equation*}
	(1,0,0),
	(0,1,1),
	(0,0,1),
	(1,1,1).
\end{equation*}
同样地，由\(A\)的合取范式
\(A = (p \lor r) \land (\neg q \lor r) \land (\neg p \lor q \lor \neg r)\)可知，
\(A\)的成假指派有\begin{equation*}
	(1,0,1),
	(1,1,0),
	(0,1,0),
	(0,0,0).
\end{equation*}

一般来说，一个命题公式的析取范式、合取范式都不是唯一的.
例如，假设\(A = p\)，
那么\((p \land q) \lor (p \land \neg q)\)和\(p\)都是\(A\)的析取范式.
这种不唯一性给有些问题的讨论带来不便.
下面根据命题公式的所有命题变元，讨论给定命题公式的唯一的标准形式：
\DefineConcept{主析取范式}和\DefineConcept{主合取范式}.

\begin{definition}
对于给定的命题变元，若由命题变元或其否定组成的合取式满足\begin{itemize}
	\item 每个命题变元或其否定两者之一只出现一次，
	\item 按字典顺序或按下标从小到大顺序出现，
\end{itemize}
则称该合取式为“由所给命题变元产生的\DefineConcept{极小项}（minimal term）”.
\end{definition}

可以证明：对于每一个极小项，只有一种指派使其取\(1\).

根据这个结论，我们可以对极小项编码：
极小项用\(m_i\)表示，
其中下标\(i\)是由成真指派得到的二进制数或对应的十进制数.

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极小项 & 成真指派 & 极小项的符号表示\(m_i\) \\
		\hline
		\(p \land q\) & 11 & \(m_{11} = m_3\) \\
		\(p \land \neg q\) & 10 & \(m_{10} = m_2\) \\
		\(\neg p \land q\) & 01 & \(m_{01} = m_1\) \\
		\(\neg p \land \neg q\) & 00 & \(m_{00} = m_0\) \\
		\hline
	\end{tblr}
	\caption{由2个命题变元\(p,q\)产生的极小项及其成真指派、符号表示}
\end{table}

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极小项 & 成真指派 & 极小项的符号表示\(m_i\) \\
		\hline
		\(p \land q \land r\) & 111 & \(m_{111} = m_7\) \\
		\(p \land q \land \neg r\) & 110 & \(m_{110} = m_6\) \\
		\(p \land \neg q \land r\) & 101 & \(m_{101} = m_5\) \\
		\(p \land \neg q \land \neg r\) & 100 & \(m_{100} = m_4\) \\
		\(\neg p \land q \land r\) & 011 & \(m_{011} = m_3\) \\
		\(\neg p \land q \land \neg r\) & 010 & \(m_{010} = m_2\) \\
		\(\neg p \land \neg q \land r\) & 001 & \(m_{001} = m_1\) \\
		\(\neg p \land \neg q \land \neg r\) & 000 & \(m_{000} = m_0\) \\
		\hline
	\end{tblr}
	\caption{由3个命题变元\(p,q,r\)产生的极小项及其成真指派、符号表示}
\end{table}

\begin{definition}
对于命题公式\(A\)，
若由\(A\)中所有命题变元产生的若干个极小项的析取等值于\(A\)，
则把该析取式称为“\(A\)的\DefineConcept{主析取范式}（major disjunctive form）”.
\end{definition}
\begin{remark}
对于命题公式\(A = A(\AutoTuple{p}{n})\)，
它的所有极小项的析取是永真式\(1\)，
它的0个极小项的析取是永假式\(0\)，
在这两种极端情况下\(A\)的主析取范式均不存在.
除了上述两种情况外，\(A\)均为中性式.
\end{remark}

%@see: 《离散数学》（邓辉文） P99
利用\emph{等值演算法}，求命题公式\(A\)的主析取范式的计算步骤：\begin{enumerate}
	\item 求出\(A\)的析取范式；
	\item 利用分配律，补充析取范式缺少的命题变元.
\end{enumerate}

%@see: 《离散数学》（邓辉文） P100
利用\emph{真值表法}，求命题公式\(A\)的主析取范式的计算步骤：\begin{enumerate}
	\item 写出命题公式\(A\)的真值表；
	\item 写出\(A\)的成真指派对应的极小项，使得该极小项在该指派下也为\(1\)；
	\item \(A\)等值于所有这样写出的极小项的析取.
\end{enumerate}

\begin{definition}
对于给定的命题变元，若由命题变元或其否定组成的析取式满足\begin{itemize}
	\item 每个命题变元或其否定两者之一只出现一次，
	\item 按字典顺序或按下标从小到大顺序出现，
\end{itemize}
则称该析取式为“由所给命题变元产生的\DefineConcept{极大项}（maximal term）”.
\end{definition}

可以证明：对于每一个极大项，只有一种指派使其取\(0\).

根据这个结论，我们可以对极大项编码：
极大项用\(M_i\)表示，
其中下标\(i\)是由成假指派得到的二进制数或对应的十进制数.

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极大项 & 成假指派 & 极大项的符号表示\(M_i\) \\
		\hline
		\(p \lor q\) & 00 & \(M_{00} = M_0\) \\
		\(p \lor \neg q\) & 01 & \(M_{01} = M_1\) \\
		\(\neg p \lor q\) & 10 & \(M_{10} = M_2\) \\
		\(\neg p \lor \neg q\) & 11 & \(M_{11} = M_3\) \\
		\hline
	\end{tblr}
	\caption{由2个命题变元\(p,q\)产生的极大项及其成假指派、符号表示}
\end{table}

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极大项 & 成假指派 & 极大项的符号表示\(M_i\) \\
		\hline
		\(p \lor q \lor r\) & 000 & \(M_{000} = M_0\) \\
		\(p \lor q \lor \neg r\) & 001 & \(M_{001} = M_1\) \\
		\(p \lor \neg q \lor r\) & 010 & \(M_{010} = M_2\) \\
		\(p \lor \neg q \lor \neg r\) & 011 & \(M_{011} = M_3\) \\
		\(\neg p \lor q \lor r\) & 100 & \(M_{100} = M_4\) \\
		\(\neg p \lor q \lor \neg r\) & 101 & \(M_{101} = M_5\) \\
		\(\neg p \lor \neg q \lor r\) & 110 & \(M_{110} = M_6\) \\
		\(\neg p \lor \neg q \lor \neg r\) & 111 & \(M_{111} = M_7\) \\
		\hline
	\end{tblr}
	\caption{由3个命题变元\(p,q,r\)产生的极大项及其成假指派、符号表示}
\end{table}

\begin{definition}
对于命题公式\(A\)，
若由\(A\)中所有命题变元产生的若干个极大项的合取等值于\(A\)，
则把该合取式称为“\(A\)的\DefineConcept{主合取范式}（major conjunctive form）”.
\end{definition}

%@see: 《离散数学》（邓辉文） P102
利用\emph{等值演算法}，求命题公式\(A\)的主合取范式的计算步骤：\begin{enumerate}
	\item 求出\(A\)的合取范式；
	\item 利用分配律，补充合取范式缺少的命题变元.
\end{enumerate}

%@see: 《离散数学》（邓辉文） P102
利用\emph{真值表法}，求命题公式\(A\)的主合取范式的计算步骤：\begin{enumerate}
	\item 写出命题公式\(A\)的真值表；
	\item 写出\(A\)的成假指派对应的极大项，使得该极大项在该指派下也为\(0\)；
	\item \(A\)等值于所有这样写出的极大项的合取.
\end{enumerate}

\begin{example}
设命题公式\(A\)的真值表如下所示，求\(A\)的主析取范式与主合取范式.
\begin{center}
	\begin{tblr}{*4c|*4c}
		\hline
		\(p\) & \(q\) & \(r\) & \(A\) & \(p\) & \(q\) & \(r\) & \(A\) \\
		\hline
		1 & 1 & 1 & 1 & 0 & 1 & 1 & 0 \\
		1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 \\
		1 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\
		1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
\begin{solution}
\(A\)等值于\(A\)的成真指派对应的极小项的析取：\begin{equation*}
	A = (p \land q \land r)
		\lor (p \land \neg q \land \neg r)
		\lor (\neg p \land \neg q \land \neg r).
\end{equation*}

\(A\)等值于\(A\)的成假指派对应的极大项的合取：\begin{equation*}
	A = (\neg p \lor \neg q \lor r)
		\land (\neg p \lor q \lor \neg r)
		\land (p \lor \neg q \lor \neg r)
		\land (p \lor \neg q \lor r)
		\land (p \lor q \lor \neg r).
\end{equation*}
\end{solution}
\end{example}
\begin{remark}
在电路实现逻辑运算时，通常选用项数较少的分解式.
在上例中，主析取范式的极小项个数为3，主合取范式的极大项个数为5，
因此最好选用主析取范式.
\end{remark}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P102 定理3-9
任意非永假命题公式都存在唯一的主析取范式.
任意非永真命题公式都存在唯一的主合取范式.
%TODO proof
\end{theorem}

\section{联结词汇集的功能完备性}
\begin{definition}
%@see: 《离散数学》（邓辉文） P106 定义3-11
设\(S\)是由联结词组成的汇集.
若任意命题公式都可由\(S\)中的联结词等值地表示出来，
则称“\(S\)是一个\DefineConcept{功能完备联结词集}（complete group of connectives）”.
\end{definition}

\begin{theorem}\label{theorem:数理逻辑.功能完备联结词集1}
%@see: 《离散数学》（邓辉文） P106 定理3-10
\(\{\neg,\land,\lor\}\)是功能完备联结词集.
\end{theorem}
\begin{corollary}
\(\{\lnor\}\)是功能完备联结词集.
\end{corollary}
\begin{corollary}
\(\{\lnand\}\)是功能完备联结词集.
\begin{proof}
因为\begin{align*}
	\neg p
	&= \neg(p \land p)
	= p \lnand p, \\
	p \land q
	&= \neg(\neg(p \land q))
	= \neg(p \lnand q)
	= (p \lnand q) \lnand (p \lnand q), \\
	p \lor q
	&= \neg(\neg p \land \neg q)
	= (\neg p) \lnand (\neg q)
	= (p \lnand p) \lnand (q \lnand q),
\end{align*}
也就是说\(\neg p\)、\(p \land q\)、\(p \lor q\)
可以由仅含\(\lnand\)的命题公式等值表示，
那么根据\cref{theorem:数理逻辑.功能完备联结词集1} 可知，
\(\{\lnand\}\)是功能完备联结词集.
\end{proof}
\end{corollary}
\begin{corollary}
\(\{\neg,\land\}\)是功能完备联结词集.
\end{corollary}
\begin{corollary}\label{theorem:数理逻辑.功能完备联结词集5}
\(\{\neg,\lor\}\)是功能完备联结词集.
\begin{proof}
因为\begin{align*}
	p \land q
	&= \neg(\neg p \lor \neg q),
\end{align*}
也就是说\(p \land q\)可由仅含\(\{\neg,\lor\}\)的命题公式等值表示，
那么根据\cref{theorem:数理逻辑.功能完备联结词集1} 可知，
\(\{\neg,\lor\}\)是功能完备联结词集.
\end{proof}
\end{corollary}
\begin{corollary}
\(\{\neg,\limp\}\)是功能完备联结词集.
\end{corollary}

\begin{example}
%@see: 《离散数学》（邓辉文） P106 例3-26
定义3元联结词\(f\)：\begin{center}
	\begin{tblr}{*4c|*4c}
		\hline
		\(p\) & \(q\) & \(r\) & \(f(p,q,r)\) & \(p\) & \(q\) & \(r\) & \(f(p,q,r)\) \\
		\hline
		1 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
		1 & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
		1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
证明：\(\{f\}\)是功能完备联结词集.
\begin{proof}
由\(f\)的真值表可知\(f(p,q,r)\)的主合取范式为\begin{equation*}
	f(p,q,r)
	= (\neg p \lor \neg q \lor \neg r)
	\land (p \lor \neg q \lor \neg r)
	\land (p \lor \neg q \lor r).
\end{equation*}
于是有\begin{equation*}
	f(p,p,p) = \neg p,
	\qquad
	f(\neg p,\neg p,\neg q) = p \lor q.
\end{equation*}
因此由\cref{theorem:数理逻辑.功能完备联结词集5} 可知，
\(\{f\}\)是功能完备联结词集.
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P107 例3-28
证明：\(\{\land,\limp\}\)不是功能完备联结词集.
\begin{proof}
对于只含有联结词\(\{\land,\limp\}\)的任意命题公式\(A\)，
在所有命题变元均取\(1\)时，\(A\)的真值为\(1\).

对\(A\)中所含的联结词个数\(n\)使用第二数学归纳法.
当\(n=0\)时，显然成立.
假设\(n = k\)时成立，当\(A\)含\(k+1\)个联结词时，
\(A = B \land C\)或\(A = B \limp C\)，
由归纳假设可知，在所有命题变元均取\(1\)时，\(B\)和\(C\)的真值为\(1\)，进而\(A\)的真值为\(1\).

对于命题变元\(p\)，
由上述讨论可知\(p \land \neg p\)不能用仅含联结词\(\{\land,\limp\}\)的命题公式等值表示，
故\(\{\land,\limp\}\)不是功能完备联结词集.
\end{proof}
\end{example}

\begin{definition}
%@see: 《离散数学》（邓辉文） P107 定义3-12
设\(S\)是功能完备联结词集，
如果\(S\)的任意非空真子集都不是功能完备联结词集，
则称“\(S\)是\DefineConcept{极小功能完备联结词集}”.
\end{definition}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P107 定理3-11
下列联结词集是极小功能完备的：\begin{itemize}
	\item \(\{\lnor\}\)；
	\item \(\{\lnand\}\)；
	\item \(\{\neg,\land\}\)；
	\item \(\{\neg,\lor\}\)；
	\item \(\{\neg,\limp\}\).
\end{itemize}
\end{theorem}

\section{命题逻辑中的推理}
逻辑学的主要内容是研究推理.
推理是从一些前提推出结论的思维过程.
实际问题中的推理，需要对前提做深入分析，才能得出结论.
例如由两直线平行，得出同位角相等；
以及由一元二次方程的判别式大于0，得出方程有两个不相等的实数根.

数理逻辑主要是用数学的方法研究逻辑中的推理，
它关心的是推理形式的有效性问题.

\subsection{推理形式有效性的定义}
\begin{definition}
%@see: 《离散数学》（邓辉文） P108 定义3-13
设\(\AutoTuple{H}{n}\)和\(C\)是命题公式.
若由\(\AutoTuple{H}{n}\)全为真，可得出\(C\)必然真，
则称“由\(\AutoTuple{H}{n}\)得出\(C\)的\DefineConcept{推理形式是有效的}（valid argument form）”
或“\(\AutoTuple{H}{n}\) \DefineConcept{逻辑推出}（logically follows） \(C\)”
或“\(\AutoTuple{H}{n}\) \DefineConcept{逻辑蕴含}（logically implies） \(C\)”，
记为\begin{equation*}
	\AutoTuple{H}{n} \implies C
	\quad\text{或}\quad
	\AutoTuple{H}{n} \vDash C;
\end{equation*}
把\(\AutoTuple{H}{n}\)称为\DefineConcept{前提}（antecedent，premise，hypothesis），
把\(C\)称为\DefineConcept{结论}（conclusion），
把\(\implies\)称为\DefineConcept{推出符号}，
把\(\AutoTuple{H}{n} \implies C\)称为\DefineConcept{推理规则}.
\end{definition}
% \(\vDash\)常用于形式系统的语义推理
% \(\vdash\)常用于形式系统的语构推理

\begin{theorem}\label{theorem:数理逻辑.推理规则的充分必要条件}
%@see: 《离散数学》（邓辉文） P109 定理3-12
设\(\AutoTuple{H}{n}\)和\(C\)是命题公式，
则\(\AutoTuple{H}{n} \implies C\)的充分必要条件是
\(H_1 \land \dotsb H_n \limp C\)是永真式.
\begin{proof}
命题公式由\(\AutoTuple{H}{n}\)全为真，
可得出\(H_1 \land \dotsb H_n\)全为真.
于是，由\(\AutoTuple{H}{n}\)全为真可得出\(C\)必然真的充分必要条件是
\(H_1 \land \dotsb H_n \limp C\)是永真式.
\end{proof}
\end{theorem}
\begin{remark}
由于成立\cref{theorem:数理逻辑.推理规则的充分必要条件}，
所以我们又把\(\AutoTuple{H}{n} \implies C\)
称为\DefineConcept{永真蕴含式}或\DefineConcept{逻辑蕴含式}，
并相应地把\(\implies\)称为\DefineConcept{永真蕴含符号}或\DefineConcept{逻辑蕴含符号}.
但是一定要注意：\(\implies\)与蕴含连接词\(\limp\)是不同的.
就两条命题公式而言，\(\implies\)是关系符号，\(A \implies B\)是逻辑蕴含式，
\(\limp\)是运算符号，\(A \limp B\)是命题公式.
\end{remark}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P109 定理3-13
设\(A\)和\(B\)是命题公式，
则\(A \iff B\)的充分必要条件是\(A \implies B\)且\(B \implies A\).
\begin{proof}
利用\(A \liff B = (A \limp B) \land (B \limp A)\)即得.
\end{proof}
\end{theorem}

可以证明：命题公式之间的永真蕴含关系是偏序关系.
\begin{theorem}
%@see: 《离散数学》（邓辉文） P109 定理3-14
设\(A,B,C\)都是命题公式，则\begin{itemize}
	\item {\rm\bf 自反性}：\(A \implies A\)；
	\item {\rm\bf 反对称性}：如果\(A \implies B\)且\(B \implies A\)，则\(A = B\)；
	\item {\rm\bf 传递性}：如果\(A \implies B\)且\(B \implies C\)，则\(A \implies C\).
\end{itemize}
\end{theorem}

\begin{theorem}
%@see: 《离散数学》（邓辉文） P109 定理3-15
设\(A,B,C\)都是命题公式，则\begin{itemize}
	\item 如果\(A \implies C\)且\(B \implies C\)，则\(A \lor B \implies C\)；
	\item 如果\(C \implies A\)且\(C \implies B\)，则\(C \implies A \land B\).
\end{itemize}
%TODO proof \cref{theorem:数理逻辑.推理规则的充分必要条件}
\end{theorem}

%@see: 《离散数学》（邓辉文） P109 定理3-16
% TODO 定理3-16 没有誊抄至此，原因是其内容包含 \sup 和 \inf 这两个符号
% 而我在此之前在《离散数学》（邓辉文）中没有看到过这两个符号

\subsection{基本推理规则}
下面举例说明，证明推理形式有效性的4种方法.

\begin{example}
%@see: 《离散数学》（邓辉文） P110 例3-29
设\(A,B\)是命题公式.
证明：\(A \limp B,A \implies B\).
\begin{proof}
\begin{proof}[证法一]
真值表法.
\begin{center}
%@Mathematica: TableForm[BooleanTable[{p, q, Implies[p, q], And[Implies[p, q], p], Implies[And[Implies[p, q], p], q]}, {p, q}] // Boole, TableHeadings -> {None, {"p", "q", "p \[Implies] q", "(p \[Implies] q)\[And]p", "((p \[Implies] q)\[And]p)\[Implies]q"}}]
	\begin{tblr}{*5c}
		\hline
		\(p\) & \(q\) & \(p \limp q\) & \((p \limp q) \land p\) & \(((p \limp q) \land p) \limp q\) \\
		\hline
		1 & 1 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 & 1 \\
		0 & 1 & 1 & 0 & 1 \\
		0 & 0 & 1 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
由真值表可见\(((p \limp q) \land p) \limp q\)是永真式，
那么由\cref{theorem:数理逻辑.推理规则的充分必要条件} 可知\(A \limp B,A \implies B\).
\end{proof}
\begin{proof}[证法二]
取值法.
假设\((p \limp q) \limp p\)取真，
则\(p \limp q\)及\(p\)均取真，
进而\(q\)为真，
因此\(((p \limp q) \land p) \limp q\)永真.
\end{proof}
\begin{proof}[证法三]
等值演算法.
\begin{align*}
	((p \limp q) \land p) \limp q
	&= ((\neg p \lor q) \land p) \limp q \\
	&= ((\neg p \land p) \lor (p \land q)) \limp q \\
	&= (p \land q) \limp q \\
	&= \neg(p \land q) \lor q \\
	&= (\neg p \lor \neg q) \lor q \\
	&= \neg p \lor (\neg q \lor q) \\
	&= \neg p \lor 1
	= 1.
	\qedhere
\end{align*}
\end{proof}
\begin{proof}[证法四]
主范式法.
\(((p \limp q) \land p) \limp q\)的主析取范式为\begin{equation*}
	(p \land q) \lor (p \land \neg q) \lor (\neg p \land q) \lor (\neg p \land \neg q).
\end{equation*}
它的主合取范式不存在.
由主范式可见\(((p \limp q) \land p) \limp q\)永真.
\end{proof}
\let\qed\relax
\end{proof}
\end{example}

\begin{example}
证明：\(p \limp q\)是\(p \land r \limp q \land r\)的充分不必要条件.
\begin{proof}
列出真值表：\begin{center}
	\begin{tabular}{*9c}
		\hline
		\(p\) & \(q\) & \(r\) & \(p \limp q\) & \(p \land r\) & \(q \land r\)
			& \(p \land r \limp q \land r\)
			& \(\begin{array}{c}
				(p \limp q) \limp \\
				(p \land r \limp q \land r)
			\end{array}\)
			& \(\begin{array}{c}
				(p \land r \limp q \land r) \\
				\limp (p \limp q)
			\end{array}\) \\
		\hline
		0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
		0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 1 \\
		0 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
		0 & 1 & 1 & 1 & 0 & 1 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
		1 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 1 \\
		1 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
		1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
		\hline
	\end{tabular}
\end{center}
立即可知\(p \limp q\)是\(p \land r \limp q \land r\)的充分不必要条件.
\end{proof}
\end{example}

\begin{table}[hbt]
%@see: 《离散数学》（邓辉文） P110 表3-20
	\centering
	\begin{tblr}{cc|c}
		\hline
		化简 & Simplification
			& \(A \land B \implies A\) \\
		附加 & Addition
			& \(A \implies A \lor B\) \\
		合取引入 & Conjunction
			& \(A,B \implies A \land B\) \\
		析取三段论 & Disjunctive Syllogism
			& \(A \lor B, \neg A \implies B\) \\
		假言推理 & Modus Ponens
			& \(A \limp B, A \implies B\) \\
		拒取式 & Modus Tollens
			& \(A \limp B, \neg B \implies \neg A\) \\
		假言三段式 & Hypothetical Syllogism
			& \(A \limp B, B \limp C \implies A \limp C\) \\
		二难推理 & Constructive Dilemma
			& \(A \lor B, A \limp C, B \limp C \implies C\) \\
		% Destructive Dilemma
		\hline
	\end{tblr}
	\caption{基本逻辑蕴含式I}
\end{table}

\subsection{命题逻辑的自然推理系统}
自然推理的构造法是判定推理形式有效性的又一种方法，
它主要是为今后进一步学习数理逻辑，尤其是为逻辑的公理化推理系统做准备的.
自然推理的基本思想是，确定一些推理规则，然后根据这些推理规则从前提出发，把结论推出来.

作为推理系统，原则上有以下4个部分：\begin{enumerate}
	\item 推理系统应该有初始符号，即一些在推理系统中允许出现的字符，
	包括命题变元（通常用小写拉丁字母表示）、
	五个联结词（即\(\neg,\land,\lor,\limp,\liff\)）
	和左右圆括号；
	\item 合式公式的定义；
	\item 公理的确立；
	\item 推理规则的确立.
\end{enumerate}

在自然推理系统中不存在公理（这一点与公理推理系统截然不同）.
它把所有与5个联结词\(\neg,\land,\lor,\limp,\liff\)有关的基本逻辑蕴含式都作为推理规则.
同时，一个基本等值式相当于两个基本逻辑蕴含式.
除了基本逻辑蕴含式和基本等值式以外，还有两个最基本的推理规则：\begin{itemize}
	\item {\rm\bf P规则}，即所给的前提在证明过程中随时可以引用；
	\item {\rm\bf T规则}，即已经推出的命题公式在以后得证明过程中可以随时引用.
\end{itemize}

由于在自然推理系统中，作为推理依据的，只有推理规则，
这似乎更符合人们日常思维的推理习惯，因此称为自然推理.

\begin{table}[hbt]
%@see: 《离散数学》（邓辉文） P111 表3-21
	\centering
	\begin{tblr}{c|c}
		\hline
		对合律 & \(\neg\neg A = A\) \\
		幂等律 & \(A \lor A = A, A \land A = A\) \\
		交换律 & \(A \lor B = B \lor A, A \land B = B \land A\) \\
		结合律 & \((A \lor B) \lor C = A \lor (B \lor C), (A \land B) \land C = A \land (B \land C)\) \\
		吸收律 & \(A \lor (A \land B) = A, A \land (A \lor B) = A\) \\
		分配律 & \(A \lor (B \land C) = (A \lor B) \land (A \lor C), A \land (B \lor C) = (A \land B) \lor (A \land C)\) \\
		互补律 & \(A \lor \neg A = 1, A \land \neg A = 0\) \\
		De Morgan 律 & \(\neg(A \lor B) = \neg A \land \neg B, \neg(A \land B) = \neg A \lor \neg B\) \\
		同一律 & \(A \lor 0 = 0 \lor A = A, A \land 1 = 1 \land A = A\) \\
		0-1 律 & \(A \lor 1 = 1 \lor A = 1, A \land 0 = 0 \land A = 0\) \\
		& \(A \limp B = \neg A \lor B\) \\
		& \(A \liff B = (A \limp B) \land (B \limp A)\) \\
		\hline
	\end{tblr}
	\caption{基本等值式E}
\end{table}

在进行自然推理时，采用构造性证明方法
（简称\DefineConcept{构造法}或\DefineConcept{演绎法}或\DefineConcept{形式证明法}）.

通过以下例子了解自然推理证明过程的书写格式.
\begin{example}
%@see: 《离散数学》（邓辉文） P112 例3-30
证明：\(p \limp (q \lor r), \neg s \limp \neg q, p \land \neg s \implies r\).
\begin{proof}
用构造法.
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \(p \land \neg s\) & P \\
		(2) & \(p\) & T(1)I \\
		(3) & \(\neg s\) & T(1)I \\
		(4) & \(p \limp (q \lor r)\) & P \\
		(5) & \(q \lor r\) & T(2)(4)I \\
		(6) & \(\neg s \limp \neg q\) & P \\
		(7) & \(\neg q\) & T(3)(6)I \\
		(8) & \(r\) & T(5)(7)I \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}
\begin{remark}
从上述证明过程可以看出，每一行由3部分组成：
第一部分是编号，说明这一行是证明的第几步；
第二部分仅给出一个命题公式；
第三部分是给出理由，交代该命题公式是怎么得来的.
\end{remark}

下面介绍两种间接的构造性证明方法.

首先介绍反证法.
要证明\(\AutoTuple{H}{n} \implies C\)，
将结论\(C\)否定得到\(\neg C\)，然后推出一个矛盾（例如\(S \land \neg S\)）即可.

这个证明方法的道理是：要证明\(\AutoTuple{H}{n} \implies C\)，
只要证\(H_1 \land \dotsb \land H_n \limp C\)永真，
即\(\neg(H_1 \land \dotsb \land H_n) \lor C\)永真，
或\(\neg(\neg(H_1 \land \dotsb \land H_n) \lor C)\)永假.
\begin{example}
%@see: 《离散数学》（邓辉文） P113 例3-33
证明：\(p \land \neg q \limp r, \neg r \land \neg q \implies \neg p\).
\begin{proof}
用反证法.
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \(\neg(\neg p)\) & P(附加) \\
		(2) & \(p\) & T(1)E \\
		(3) & \(\neg r \land \neg q\) & P \\
		(4) & \(\neg q\) & T(3)I \\
		(5) & \(p \land \neg q\) & T(2)(4)I \\
		(6) & \(p \land \neg q \limp r\) & P \\
		(7) & \(r\) & T(5)(6)I \\
		(8) & \(\neg r\) & T(3)I \\
		(9) & \(r \land \neg r\) & T(7)(8)I \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}

下面介绍条件证明规则.
对于形如\(\AutoTuple{H}{n} \implies A \limp C\)的推理，
只需要证明\(\AutoTuple{H}{n},A \implies C\)，
这就是采用\DefineConcept{条件证明规则}的证明方法，
它是将\(A \limp C\)的前件\(A\)和后件\(C\)分离的一种证明方法.

这个证明方法的道理是：\begin{align*}
	&\AutoTuple{H}{n} \implies A \limp C \\
	&= (H_1 \land \dotsb \land H_n) \limp (A \limp C) \\
	&= \neg(H_1 \land \dotsb \land H_n) \lor (\neg A \lor C) \\
	&= (\neg(H_1 \land \dotsb \land H_n) \lor \neg A) \lor C \\
	&= \neg(H_1 \land \dotsb \land H_n \land A) \lor C \\
	&= (H_1 \land \dotsb \land H_n \land A) \limp C \\
	&= \AutoTuple{H}{n},A \implies C,
\end{align*}
也就是说，\(\AutoTuple{H}{n} \implies A \limp C\)永真的充分必要条件是
\(\AutoTuple{H}{n},A \implies C\)永真.

\begin{example}
%@see: 《离散数学》（邓辉文） P114 例3-34
证明：\(p \limp (q \lor r), q \limp \neg p, s \limp \neg r \implies p \limp \neg s\).
\begin{proof}
用条件证明规则.
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \(p \limp (q \lor r)\) & P \\
		(2) & \(p\) & P(附加) \\
		(3) & \(q \lor r\) & T(1)(2)I \\
		(4) & \(q \limp \neg p\) & P \\
		(5) & \(\neg q \lor \neg p\) & T(4)E \\
		(6) & \(\neg q\) & T(2)(5)I \\
		(7) & \(r\) & T(3)(6)I \\
		(8) & \(s \limp \neg r\) & P \\
		(9) & \(\neg s \lor \neg r\) & T(8)E \\
		(10) & \(\neg s\) & T(7)(9)I \\
		(11) & \(p \limp \neg s\) & CP \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}

数理逻辑的主要研究任务是建立一个严密的逻辑推理系统 --- 公理推理系统 --- 来刻画人类的思维规律，
这个系统与上述自然推理系统是类似的，但它有更精简的初始符号、公式的形成规则、公理和推理规则.
已有的逻辑演算形式系统，例如\emph{命题演算的形式系统}（formal system of proposition calculus），
在理论上证明了其合理性、一致性、完备性等与语法、语义有关的重要结论，
可以得出人类思维的所有推理规则，
所提供的逻辑推理框架能保证在前提为真的条件下，总能得出正确的结论.

\chapter{谓词逻辑}
原子命题是命题逻辑研究的基本单位，
没有对原子命题的内部结构及其逻辑关系进行讨论.
在实际思维中，仅有命题逻辑工具是不够的.
例如著名的苏格拉底三段论：
大前提是“所有的人都是要死的”，
小前提是“苏格拉底是人”，
结论是“所以，苏格拉底是要死的”.
这个推理的有效性在命题逻辑中无法证明，
因为上述每个命题都是原子命题，
可以分别用\(p,q,r\)表示，
然而\(p,q \implies r\)在命题逻辑中是无效推理.

之所以出现这种推理本身是正确的，但无法证明其有效性的问题，
是因为没有对原子命题的内部形式结构及其逻辑关系进行讨论，
这正是谓词逻辑首先要研究的内容，这些讨论涉及集合、映射、运算和关系.

本章讨论的谓词逻辑又称为一阶逻辑.

\section{个体、谓词、量词和函词}
\subsection{个体}
在谓词逻辑中，命题的考虑对象称为\DefineConcept{个体}（individual）.
个体是独立存在的事物.
个体可以是具体的，也可以是抽象的.

表示特定的、具体的个体，称为\DefineConcept{个体常量}（constant）.

不确定的个体，称为\DefineConcept{个体变元}（variable）.

个体常量和个体变元通常用小写拉丁字母表示，
例如\(a,b,c,\dotsc,x,y,z\).

在讨论个体时，通常要制定个体讨论的范围，
称为\DefineConcept{个体域}（domain of individuals）
或\DefineConcept{论域}（domain of discourse，universe），
用\(D\)表示，一般假定\(D\)非空.

个体域可以是有限汇集，也可以是无限汇集.
我们把人类能够反映、认知的一切事物的汇集，
称为\DefineConcept{全总个体域}，简称\DefineConcept{全域}.

\subsection{谓词}
我们把表示个体性质以及个体之间关系的词称为\DefineConcept{谓词}（predicate）.

表示一个个体性质的谓词称为1元谓词.
表示\(n\ (n\geq0)\)个个体之间关系的谓词称为\(n\)元谓词.
谓词通常用大写拉丁字母表示，例如\(P,Q,R\).
为了强调\(n\)元谓词的元数，
会像表示\(n\)元函数一样，
在大写拉丁字母后面添上圆括号，并在括号内添上\(n\)个个体变元，
例如\(P(\AutoTuple{x}{n})\).

对于\(n\)元谓词\(P(\AutoTuple{x}{n})\ (n\geq1)\)，
当个体变元\(\AutoTuple{x}{n}\)取定个体域中的元素后，就成为一个命题，
例如\begin{equation*}
	G(x,y):
	x>y,
\end{equation*}
它是关于命题的函数，称为\DefineConcept{命题函数}（propositional function）.
显然，命题函数不是命题.

\begin{remark}
谓词的选取与个体域有关.
例如，对于命题“所有人都是要死的”，
若在所有人组成的个体域中考虑，
只需一个谓词\begin{equation*}
	D(x):
	\text{$x$是要死的};
\end{equation*}
若在全域中考虑，则需要两个谓词\begin{equation*}
	P(x):
	\text{$x$是人},
	\qquad
	D(x):
	\text{$x$是要死的},
\end{equation*}
其中\(P(x)\)称为\DefineConcept{特性谓词}，
我们用这个谓词将“人”从全域中分离出来.
\end{remark}

\subsection{量词}
对于命题函数，例如\begin{equation*}
	P(x):
	\text{$x$是素数},
\end{equation*}
当个体域\(D\)为自然数集\(\mathbb{N}\)时，
对于\(x\)的每一个取值，就有一个命题.
这是使\(P(x)\)成为命题的一种方法.

使\(P(x)\)成为命题的另一种方法是，
量化个体变元\(x\)，
常用方法有两种：全称量化和存在量化.

把表示个体数量特征的词称为\DefineConcept{量词}（quantifier）.
常见的量词有\DefineConcept{全称量词}~\(\color{blue}\forall\)（universal quantifier）、
\DefineConcept{存在量词}~\(\color{blue}\exists\)（existential quantifier）、
\DefineConcept{唯一量词}~\(\color{blue}\exists!\).

由于在本章中，仅对个体进行量化，不对谓词进行量化，
因此把本章介绍的谓词逻辑特别称为\DefineConcept{一阶谓词逻辑}.

在使用量词时，必须要指明量化的个体变元，
例如\(\forall x,\forall y,\exists x,\exists y\).
单独使用量词是没有意义的.
我们把量词后面跟着的个体变元称为\DefineConcept{指导变元}.

若将命题函数中的所有个体变元都进行了量化，则得到一个命题，否则不是命题.

量词是对个体变元进行量化，所给的个体域\(D\)至关重要.
同一个带量词的命题，
例如\begin{equation*}
	(\exists x)(\exists y)[G(x,y)],
\end{equation*}
其中\(G(x,y): x>y\)，
它在自然数集\(\mathbb{N}\)中表示没有最小的自然数，是假命题；
它在整数集\(\mathbb{Z}\)中表示没有最小的整数，是真命题.

我们把量词\(\forall\)或\(\exists\)的作用范围
称为它的\DefineConcept{作用域}或\DefineConcept{辖域}（scope），
辖域内的个体变元称为\DefineConcept{约束变元}（bound variable）.

若量词后有括号，则括号里面的部分是它的辖域.

若令\begin{equation*}
	P(x):
	\text{$x$是人},
	\qquad
	D(x):
	\text{$x$是要死的},
\end{equation*}
则“所有的人都是要死的”可以表示为\begin{equation*}
	(\forall x)[P(x) \limp D(x)],
\end{equation*}
这时\(\forall x\)的辖域为\(P(x) \limp D(x)\)，
其中两次出现的\(x\)是约束变元.

不受任何量词约束的变元称为\DefineConcept{自由变元}（free variable）.
例如\begin{equation*}
	(\forall x)[G(x,y)]
\end{equation*}中的\(y\)，
它不受\(\forall x\)的约束，这时\(G(x,y)\)中的\(y\)是自由变元.

\subsection{函词}
个体变元的函数称为\DefineConcept{函词}（function）.

例如，令个体域\(D\)取所有人组成的集合，用\(f(x)\)表示“\(x\)的父亲”，
则\(f\)是从\(D\)到\(D\)的一元函词.

又例如，令\(D \defeq \mathbb{R}\)，再令\(f(x,y) \defeq x^2 + y^2\)，
则\(f\)是从\(D^2\)到\(D\)的二元函词.

\section{谓词公式及命题的符号化}
\subsection{谓词公式}
%TODO 谓词公式的定义

我们将满足以下条件的公式称为\DefineConcept{合式谓词公式}（well-formed predicate formula），
简称\DefineConcept{合式公式}（well-formed formula）：
\begin{enumerate}
	\item 如果\(a\)和\(b\)是自由变元，那么\([a \in b]\)是一个合式公式.
	这样的合式公式又被称为是\DefineConcept{原子的}（atomic），
	或者称这样的公式为\DefineConcept{原子公式}.
	% If \(a\) and \(b\) are free variables, then \([a \in b]\) is a wff.
	% Such formulas are called atomic.

	\item 如果\(\phi\)和\(\psi\)是合式公式，那么\begin{equation*}
		\neg \phi, \qquad
		[\phi \lor \psi], \qquad
		[\phi \land \psi], \qquad
		[\phi \limp \psi], \qquad
		[\phi \liff \psi]
	\end{equation*}
	都是合式公式.
	% If \(\phi\) and \(\psi\) are wffs, then \(
	% 	\neg \phi,
	% 	[\phi \lor \psi],
	% 	[\phi \land \psi],
	% 	[\phi \limp \psi],
	% 	[\phi \liff \psi]
	% \) are wffs.

	\item 如果\(\phi\)是合式公式，\(x\)是约束变元，那么\begin{equation*}
		(\forall x)[\phi(x)]
		\quad\text{和}\quad
		(\exists x)[\phi(x)]
	\end{equation*}
	都是合式公式，
	其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
	用约束变元\(x\)代替某个自由变元\(a\)从而得到的公式.
	我们将这两个公式分别称为
	“通过\DefineConcept{全称量化}变元\(a\)，从\(\phi\)得到的公式
	（the formula obtained from \(\phi\) by universally quantifying on the variable \(a\)）”
	和“通过\DefineConcept{存在量化}变元\(a\)，从\(\phi\)得到的公式
	（the formula obtained from \(\phi\) by existentially quantifying on the variable \(a\)）”.
	% If \(\phi\) is a wff and x is a bound variable,
	% then \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) are wffs,
	% where \(\phi(x)\) is the formula obtained from the wff \(\phi\)
	% by replacing each occurrence of some free variable \(a\) by the bound variable \(x\).
	% We call \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) respectively,
	% the formula obtained from \(\phi\) by universally, or existentially,
	% quantifying on the variable \(a\).
\end{enumerate}
任意一条公式，当且仅当它可以由上述三条规则演绎推得时，我们才称其为合式公式.
% A formula is well formed if and only if its being so is deducible from rules (1)-(3) above.

%@see: 《离散数学》（邓辉文） P122
不含自由变元的谓词公式，称为\DefineConcept{闭式}（closed forumla）；
反之，含有自由变元的谓词公式，称为\DefineConcept{开式}（open forumla）.

\subsection{命题的符号化}
在一阶谓词逻辑中，将命题符号化时，必须使用谓词，并按以下步骤进行：
第一步是找出所给命题中的所有个体常量，分别符号化；
第二步是确定给定个体域中应该选用的所有谓词，特别注意特性谓词的选取；
第三步是确定量词、函词、联结词.

% \subsection{逻辑公理，推理规则}
% 我们有如下五条逻辑公理：
% \begin{axiom}
% \((\forall x)[\phi \limp \psi(x)] \limp [\phi \limp (\forall x) \psi(x)]\)，
% 其中，我们量化的自由变元\(a\)没有出现在公式\(\phi\)中.
% %where the free variable \(a\) on which we are quantifying does not occur in \(\phi\).
% \end{axiom}
% \begin{axiom}
% \((\forall x) \phi(x) \limp \phi(a)\)，
% 其中，\(\phi(a)\)是通过用自由变元\(a\)代替\(\phi(x)\)中的约束变元\(x\)得到的公式.
% %where \(\phi(a)\) is the forumla
% %obtained by replacing each occurrence
% %of the bound variable x
% %in \(\phi(x)\) by the free variable \(a\).
% \end{axiom}
% 以及如下两条\DefineConcept{推理规则}（rules of inference）：
% \begin{axiom}
% 从\(\phi\)和\(\phi \limp \psi\)，可以推断\(\psi\).
% %From \(\phi\) and \(\phi \limp \psi\) to infer \(\psi\).
% \end{axiom}
% \begin{axiom}
% 从\(\phi\)，可以推断\((\forall x) \phi(x)\)，
% 其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
% 用约束变元\(x\)代替某个自由变元从而得到的公式.
% %From \(\phi\) to infer \((\forall x)\) \phi(x)
% %where \(\phi(x)\) is obtained from \(\phi\)
% %by replacing each occurrence of some free variable by x.
% \end{axiom}

\section{谓词公式的解释及类型}
\subsection{谓词公式的解释}
谓词公式的取值，取决于对它进行的解释或赋值，有如对命题公式的指派.
但与命题公式不同的时，谓词公式的解释有无限多种，
每种\DefineConcept{解释}（interpretation）由下面5个部分组成：\begin{enumerate}
	\item 指定个体域；
	\item 为谓词公式中的命题变元指派其真值；
	\item 将谓词公式中的个体常量及其自由变元解释为指定个体域中的元素；
	\item 将谓词公式中的函词解释为个体域上的函数；
	\item 将谓词公式中的谓词解释为个体域上的谓词.
\end{enumerate}

当把谓词公式中的个体常量\(a\)解释为个体域\(D\)中的个体\(\alpha\)时，
记作\(\frac{a}{\alpha}\).

谓词公式在任何解释下都会取得一个真值.
假设个体域是\(D\)，
且\(D\)是有限的
\footnote{
	根据定义，谓词公式是\emph{有限的}符号序列，所以不可以无限合取或无限析取.
	%@see: https://plato.stanford.edu/entries/logic-infinitary/
}，
则有以下两个消去量词的逻辑等值式：\begin{gather}
	(\forall x)[P(x)]
	= \bigwedge_{d \in D} P(d), \\
	(\exists x)[P(x)]
	= \bigvee_{d \in D} P(d).
\end{gather}

\subsection{谓词公式的类型}
%@see: 《离散数学》（邓辉文） P127 定义4-1
在任何解释下均为真的谓词公式称为\DefineConcept{永真式}或\DefineConcept{有效式}（valid）.

\begin{example}
%@see: 《离散数学》（邓辉文） P127 例4-9
证明谓词公式\((\forall x)[A(x)] \limp A(t)\)永真.
% \begin{proof}
% 任意给定个体域\(D\)上的解释\(I\)，
% 假定\((\forall x)[A(x)]\)在该解释下取\(1\)，
% 则对于任意\(d \in D\)，
% 总有\(A(d)\)取\(1\)，
% 于是\(A(t)\)取\(1\).
% \end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P127 例4-10
证明谓词公式\(
	(\forall x)[A(x)]
	\lor
	(\forall x)[B(x)]
	\limp
	(\forall x)
	[
		A(x) \lor B(x)
	]
\)永真.
% \begin{proof}
% 任意给定个体域\(D\)上的解释\(I\)，
% 假定\((\forall x)[A(x)] \lor (\forall x)[B(x)]\)在该解释下取\(1\)，
% 则\((\forall x)[A(x)]\)或\((\forall x)[B(x)]\)取\(1\)，
% 这时\((\forall x)[A(x) \lor B(x)]\)取\(1\)，
% 因此\(
% 	(\forall x)[A(x)]
% 	\lor
% 	(\forall x)[B(x)]
% 	\limp
% 	(\forall x)
% 	[
% 		A(x) \lor B(x)
% 	]
% \)永真.
% \end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P127 例4-11
证明谓词公式\(
	(\exists x)
	(\forall y)
	[A(x,y)]
	\limp
	(\forall y)
	(\exists x)
	[A(x,y)]
\)永真.
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P128 习题4.3 7.
证明谓词公式\(
	(\exists x)
	[
		A(x) \lor B(x)
	]
	\limp
	(\exists x)
	[A(x)]
	\lor
	(\exists x)
	[B(x)]
\)永真.
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P128 习题4.3 8.(1)
证明谓词公式\(
	(\forall x)
	[A(x)]
	\limp
	(\exists x)
	[A(x)]
\)永真.
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P128 习题4.3 8.(2)
证明谓词公式\(
	(\forall x)
	(\forall y)
	[A(x,y)]
	\limp
	(\forall x)
	(\exists y)
	[A(x,y)]
\)永真.
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P128 习题4.3 8.(3)
证明谓词公式\(
	(\forall x)
	(\exists y)
	[A(x,y)]
	\limp
	(\exists x)
	(\exists y)
	[A(x,y)]
\)永真.
\end{example}

%@see: 《离散数学》（邓辉文） P127 定义4-2
至少存在一种解释使其成真的谓词公式称为\DefineConcept{可满足式}，
否则称为\DefineConcept{不可满足式}或\DefineConcept{矛盾式}或\DefineConcept{永假式}.

既存在取\(1\)的解释，又存在取\(0\)的解释的谓词公式
称为\DefineConcept{中性式}或\DefineConcept{偶然式}.

\begin{theorem}
%@see: 《离散数学》（邓辉文） P127
% 1936年丘奇和图灵分别独立证明了：
中性谓词公式无法在有限步内判定.
永真谓词公式、永假谓词公式可以在有限步内判定.
\end{theorem}

\section{逻辑等值的谓词公式}
\subsection{谓词公式等值的定义}
与两个命题公式等值完全类似，我们可以给出两个谓词公式等值的定义.
\begin{definition}
%@see: 《离散数学》（邓辉文） P129 定义4-3
设\(A,B\)是谓词公式.
若\(A\)和\(B\)在任何解释下的取值都相同，
则称“\(A\)和\(B\)是逻辑等值的”，
记为\(A=B\).
\end{definition}

显然，\(A=B\)的充分必要条件是谓词公式\(A \liff B\)永真.

根据命题逻辑中的等值式，容易得到一些谓词逻辑中的等值式.

\subsection{基本等值式}
\subsubsection{量词转换}
%@see: 《离散数学》（邓辉文） P129
%@see: 《离散数学》（邓辉文） P131 习题4.4 1.
设谓词公式\(A\)含自由变元\(x\)，
则\begin{gather}
	\neg(\forall x)[A(x)]
	= (\exists x)[\neg A(x)],
	\label{equation:数理逻辑.量词转换1} \\
	\neg(\exists x)[A(x)]
	= (\forall x)[\neg A(x)].
	\label{equation:数理逻辑.量词转换2}
\end{gather}

\subsubsection{量词辖域的收缩与扩张}
%@see: 《离散数学》（邓辉文） P129
%@see: 《离散数学》（邓辉文） P131 习题4.4 2.
设谓词公式\(A\)含自由变元\(x\)，
谓词公式\(B\)中不含自由变元\(x\)，
则\begin{gather}
	(\forall x)[A(x) \land B]
	= (\forall x)[A(x)] \land B, \\
	(\forall x)[A(x) \lor B]
	= (\forall x)[A(x)] \lor B, \\
	(\exists x)[A(x) \land B]
	= (\exists x)[A(x)] \land B, \\
	(\exists x)[A(x) \lor B]
	= (\exists x)[A(x)] \lor B.
\end{gather}

\begin{example}
%@see: 《离散数学》（邓辉文） P130 例4-13(1)
证明：\begin{equation}
	(\forall x)[A(x) \limp B]
	= (\exists x)[A(x)] \limp B.
\end{equation}
\begin{proof}
显然\begin{align*}
	(\forall x)[A(x) \limp B]
	&= (\forall x)[\neg A(x) \lor B] \\
	&= (\forall x)[\neg A(x)] \lor B \\
	&= \neg(\exists x)[A(x)] \lor B \\
	&= (\exists x)[A(x)] \limp B.
	\qedhere
\end{align*}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P130 例4-13(2)
证明：\begin{equation}
	(\forall x)[B \limp A(x)]
	= B \limp (\forall x)[A(x)].
\end{equation}
\begin{proof}
显然\begin{align*}
	(\forall x)[B \limp A(x)]
	&= (\forall x)[\neg B \lor A(x)] \\
	&= \neg B \lor (\forall x)[A(x)] \\
	&= B \limp (\forall x)[A(x)].
	\qedhere
\end{align*}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P130 例4-13(3)
%@see: 《离散数学》（邓辉文） P131 习题4.4 3.(1)
证明：\begin{equation}
	(\exists x)[A(x) \limp B]
	= (\forall x)[A(x)] \limp B.
\end{equation}
\begin{proof}
显然\begin{align*}
	(\exists x)[A(x) \limp B]
	&= (\exists x)[\neg A(x) \lor B] \\
	&= (\exists x)[\neg A(x)] \lor B \\
	&= \neg(\forall x)[A(x)] \lor B \\
	&= (\forall x)[A(x)] \limp B.
	\qedhere
\end{align*}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P130 例4-13(4)
%@see: 《离散数学》（邓辉文） P131 习题4.4 3.(2)
证明：\begin{equation}
	(\exists x)[B \limp A(x)]
	= B \limp (\exists x)[A(x)].
\end{equation}
\begin{proof}
显然\begin{align*}
	(\exists x)[B \limp A(x)]
	&= (\exists x)[\neg B \lor A(x)] \\
	&= \neg B \lor (\exists x)[A(x)] \\
	&= B \limp (\exists x)[A(x)].
	\qedhere
\end{align*}
\end{proof}
\end{example}

\subsubsection{量词分配律}
%@see: 《离散数学》（邓辉文） P130
%@see: 《离散数学》（邓辉文） P131 习题4.4 4.
设谓词公式\(A,B\)都含自由变元\(x\)，
则\begin{gather}
	(\forall x)[A(x) \land B(x)]
	= (\forall x)[A(x)] \land (\forall x)[B(x)], \\
	(\exists x)[A(x) \lor B(x)]
	= (\exists x)[A(x)] \lor (\exists x)[B(x)].
\end{gather}
\begin{remark}
量词\(\forall\)对\(\land\)可分配，
但是\((\forall x)[A(x) \lor B(x)]
\neq (\forall x)[A(x)] \lor (\forall x)[B(x)]\).
例如，令个体域\(D=\mathbb{Z}\)，
令\(A(x): \text{$x$是偶数}\)，
令\(B(x): \text{$x$是奇数}\)，
则\((\forall x)[A(x) \lor B(x)]\)在上述解释下取真，
而\((\forall x)[A(x)] \lor (\forall x)[B(x)]\)在上述解释下取假.

同样地，
量词\(\exists\)对\(\lor\)可分配，
但是\((\exists x)[A(x) \land B(x)]
\neq (\exists x)[A(x)] \land (\exists x)[B(x)]\).
\end{remark}

\begin{example}
%@see: 《离散数学》（邓辉文） P131 习题4.4 5.
证明：\begin{equation}
	(\exists x)[A(x) \limp B(x)]
	= (\forall x)[A(x)] \limp (\exists x)[B(x)].
\end{equation}
\begin{proof}
显然\begin{align*}
	(\exists x)[A(x) \limp B(x)]
	&= (\exists x)[\neg A(x) \lor B(x)] \\
	&= (\exists x)[\neg A(x)] \lor (\exists x)[B(x)] \\
	&= \neg(\forall x)[A(x)] \lor (\exists x)[B(x)] \\
	&= (\forall x)[A(x)] \limp (\exists x)[B(x)].
	\qedhere
\end{align*}
\end{proof}
\end{example}

\subsubsection{双重量词}
%@see: 《离散数学》（邓辉文） P130
设谓词公式\(A\)含自由变元\(x\)和\(y\)，
则\begin{gather}
	(\forall x)(\forall y)[A(x,y)]
	= (\forall y)(\forall x)[A(x,y)], \\
	(\exists x)(\exists y)[A(x,y)]
	= (\exists y)(\exists x)[A(x,y)].
\end{gather}
\begin{remark}
\((\forall x)(\exists y)[A(x,y)]
\neq (\exists y)(\forall x)[A(x,y)]\).
\end{remark}

\begin{example}
%@see: 《离散数学》（邓辉文） P130 例4-14
证明：\begin{equation}
	(\forall x)(\forall y)[A(x) \limp B(y)]
	= (\exists x)[A(x)] \limp (\forall y)[B(y)].
\end{equation}
\begin{proof}
显然\begin{align*}
	(\forall x)(\forall y)[A(x) \limp B(y)]
	&= (\forall x)(\forall y)[\neg A(x) \lor B(y)] \\
	&= (\forall x)
		[
			(\forall y)
			[
				\neg A(x) \lor B(y)
			]
		] \\
	&= (\forall x)
		[
			\neg A(x)
			\lor
			(\forall y)[B(y)]
		] \\
	&= (\forall x)[\neg A(x)] \lor (\forall y)[B(y)] \\
	&= \neg(\exists x)[A(x)] \lor (\forall y)[B(y)] \\
	&= (\exists x)[A(x)] \limp (\forall y)[B(y)].
	\qedhere
\end{align*}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P131 习题4.4 6.(1)
证明：\begin{equation}
	(\forall x)(\forall y)[A(x) \lor B(y)]
	= (\forall x)[A(x)] \lor (\forall y)[B(y)].
\end{equation}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P131 习题4.4 6.(2)
证明：\begin{equation}
	(\exists x)(\exists y)[A(x) \land B(y)]
	= (\exists x)[A(x)] \land (\exists y)[B(y)].
\end{equation}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P131 习题4.4 6.(3)
证明：\begin{equation}
	(\exists x)(\exists y)[A(x) \limp B(x)]
	= (\forall)[A(x)] \limp (\exists y)[B(y)].
\end{equation}
\end{example}

\section{前束范式}
\subsection{前束范式的概念}
\begin{definition}
%@see: 《离散数学》（邓辉文） P131 定义4-4
设\(A\)是谓词公式.
\def\Q{\raisebox{.6em}{\rotatebox{180}{Q}}}
若\(A = (\Q_1 x_1)(\Q_2 x_2)\dotso(\Q_n x_n)[B]\ (n\geq0)\)，
其中\(\Q_i\ (i=1,2,\dotsc,n)\)要么是\(\forall\)要么是\(\exists\)，
\(B\)中不含量词，
则称“\((\Q_1 x_1)(\Q_2 x_2)\dotso(\Q_n x_n)[B]\)是
\(A\)的\DefineConcept{前束范式}（prenex normal form）”.
\end{definition}

直观地说，谓词公式的前束范式是将它的所有量词放到最前面去作用整个\(B\).
例如，\(A = (\forall x)[P(x)] \limp Q(x,y)\)不是\(A\)的前束范式.

\subsection{前束范式的计算}
前束范式的计算步骤如下：\begin{enumerate}
	\item 将原本的谓词公式归约为只含\(\neg,\land,\lor\)的谓词公式；
	\item 使用\cref{equation:数理逻辑.量词转换1,equation:数理逻辑.量词转换2}
	这两个等值式，将否定联结词从外向里移动.
\end{enumerate}

\section{谓词逻辑中的推理}
\subsection{逻辑蕴含式}
\begin{example}
%@see: 《离散数学》（邓辉文） P133 例4-19
证明：\((\forall x)[A(x)] \implies A(t)\).
\begin{proof}
%TODO 由例4-9可知，
\((\forall x)[A(x)] \limp A(t)\)永真.
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P133 例4-20
证明：\((\exists x)(\forall y)[A(x,y)] \implies (\forall y)(\exists x)[A(x,y)]\).
\begin{proof}
任意给定个体域\(D\)上的解释\(I\)，
假定\((\exists x)(\forall y)[A(x,y)]\)在解释\(I\)下取真，
则存在\(d_0 \in D\)，
对于任意\(d \in D\)，
均有\(A(d_0,d)\)取真，
于是\((\forall y)(\exists x)[A(x,y)]\)在解释\(I\)下取真.
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P133 例4-21
证明：\((\exists y)(\forall x)[A(x,y)]\)不是\((\forall x)(\exists y)[A(x,y)]\)的有效结论.
\begin{proof}
令个体域\(D=\mathbb{R}\)，
\(A(x,y): x>y+3\)，
则\((\forall x)(\exists y)[A(x,y)]\)表示
“对于任意实数\(x\)，均存在实数\(y\)，使得\(x>y+3\)”，
它是真命题；
而\((\exists y)(\forall x)[A(x,y)]\)表示
“存在实数\(y\)，对于任意实数\(x\)，都有\(x>y+3\)”，
它是假命题；
所以\((\forall x)(\exists y)[A(x,y)] \limp (\exists y)(\forall x)[A(x,y)]\)不是永真式，
因此\((\exists y)(\forall x)[A(x,y)]\)不是\((\forall x)(\exists y)[A(x,y)]\)的有效结论.
\end{proof}
\end{example}

\subsection{基本推理规则}
命题逻辑中的基本推理规则可以很方便地推广到谓词逻辑.

谓词逻辑有两个非常重要的、与量词有关的逻辑蕴含式.
\begin{theorem}\label{theorem:一阶逻辑.基本推理规则}
%@see: 《离散数学》（邓辉文） P133 定理4-1
设谓词公式\(A,B\)都含自由变元\(x\)，
则\begin{gather}
	(\forall x)[A(x)] \lor (\forall x)[B(x)]
	\implies (\forall x)[A(x) \lor B(x)], \\
	(\exists x)[A(x) \land B(x)]
	\implies (\exists x)[A(x)] \land (\exists x)[B(x)].
\end{gather}
\end{theorem}

\begin{example}
%@see: 《离散数学》（邓辉文） P134 例4-22(1)
设谓词公式\(A,B\)都含自由变元\(x\)，
举例说明\begin{equation*}
	\neg(\forall x)[A(x)] \implies (\forall x)[\neg A(x)]
\end{equation*}不成立.
\begin{solution}
因为\(
	%\cref{equation:数理逻辑.量词转换1}
	\neg(\forall x)[A(x)]
	= (\exists x)[\neg A(x)]
\)，
而\((\exists x)[\neg A(x)]\)显然不能推出\((\forall x)[\neg A(x)]\).
例如，取个体域\(D = \mathbb{Z}\)，
令\(A(x): \text{$x$是偶数}\)，
则\((\forall x)[A(x)]\)是假命题，
从而\(\neg(\forall x)[A(x)]\)是真命题，
而\((\forall x)[\neg A(x)]\)表示“任意整数都不是偶数”，它是假命题，
因此结论\(\neg(\forall x)[A(x)] \implies (\forall x)[\neg A(x)]\)不成立.
\end{solution}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P134 例4-22(2)
设谓词公式\(A,B\)都含自由变元\(x\)，
举例说明\begin{equation*}
	(\exists x)[A(x) \limp B(x)] \implies (\exists x)[A(x)] \limp (\exists x)[B(x)]
\end{equation*}不成立.
\begin{proof}
取个体域\(D = \{1,2\}\)，
解释\(
	\frac{A(1)}1,
	\frac{A(2)}0,
	\frac{B(1)}0,
	\frac{B(2)}0
\).
这时因为\(A(2) \limp B(2)\)是真命题，
于是\((\exists x)[A(x) \limp B(x)]\)是真命题；
而\(A(1)\)为真，
即\((\exists x)[A(x)]\)为真；
但\((\exists x)[B(x)]\)为假；
所以\((\exists x)[A(x)] \limp (\exists x)[B(x)]\)在上述解释下为假，
因此\((\exists x)[A(x) \limp B(x)] \implies (\exists x)[A(x)] \limp (\exists x)[B(x)]\)不成立.
\end{proof}
\end{example}

\subsection{自然推理系统}
谓词逻辑的自然推理系统是对命题逻辑的自然推理系统的一种推广.
相比于命题逻辑，
谓词逻辑的初始符号，增加了函词、谓词、量词；
新建了谓词公式的形成规则；
依然没有公理；
基本推理规则除了\cref{theorem:一阶逻辑.基本推理规则} 引入的两个逻辑蕴含式以外，
还有以下4个与量词有关的基本推理规则：\begin{enumerate}
	\item {\rm\bf 全称量词消去规则}：\begin{equation*}
		(\forall x)[A(x)] \implies A(c)\ (\text{$c$是个体域中任意个体}).
	\end{equation*}

	\item {\rm\bf 全称量词产生规则}：\begin{equation*}
		A(c)\ (\text{$c$是个体域中任意个体}) \implies (\forall x)[A(x)].
	\end{equation*}

	\item {\rm\bf 存在量词消去规则}：\begin{equation*}
		(\exists x)[A(x)] \implies A(c)\ (\text{$c$是个体域中某个体，且$c$与其他自由变元无关}).
	\end{equation*}

	\item {\rm\bf 存在量词产生规则}：\begin{equation*}
		A(c)\ (\text{$c$是个体域中某个体}) \implies (\exists x)[A(x)].
	\end{equation*}
\end{enumerate}

\begin{example}
%@see: 《离散数学》（邓辉文） P134 例4-23
证明苏格拉底三段论推理的有效性.
\begin{proof}
令\(s: \text{苏格拉底},
P(x): \text{$x$是人},
D(x): \text{$x$是要死的}\)，
则苏格拉底三段论
“所有的人都是要死的，苏格拉底是人，所以，苏格拉底是要死的”
可以转写为\begin{equation*}
	(\forall x)[P(x) \limp D(x)],
	P(s)
	\implies
	D(s).
\end{equation*}
于是
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \(P(s)\) & P \\
		(2) & \((\forall x)[P(x) \limp D(x)]\) & P \\
		(3) & \(P(s) \limp D(s)\) & US(2) \\
		(4) & \(D(s)\) & T(1)(3)I \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P134 例4-24
证明：\((\forall x)[F(x) \limp G(x)],
(\exists x)[F(x)]
\implies
(\exists x)[G(x)]\).
\begin{proof}
用构造法.
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \((\exists x)[F(x)]\) & P \\
		(2) & \(F(c)\) & ES(1) \\
		(3) & \((\forall x)[F(x) \limp G(x)]\) & P \\
		(4) & \(F(c) \limp G(c)\) & US(3) \\
		(5) & \(G(c)\) & T(2)(4)I \\
		(6) & \((\exists x)[G(x)]\) & EG(5) \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}

\begin{example}
%@see: 《离散数学》（邓辉文） P135 例4-25
证明：\(\neg(\exists x)[F(x) \land H(x)],
(\forall x)[G(x) \limp H(x)]
\implies
(\forall x)[G(x) \limp \neg F(x)]\).
\begin{proof}
用构造法.
\begin{center}
	\begin{tblr}{cp{4cm}l}
		(1) & \(\neg(\exists x)[F(x) \land H(x)]\) & P \\
		(2) & \((\forall x)[\neg F(x) \lor \neg H(x)]\) & T(1)E \\
		(3) & \(\neg F(c) \lor \neg H(c)\) & US(2) \\
		(4) & \(H(c) \limp \neg F(c)\) & T(3)E \\
		(5) & \((\forall x)[G(x) \limp H(x)]\) & P \\
		(6) & \(G(c) \limp H(c)\) & US(5) \\
		(7) & \(G(c) \limp \neg F(c)\) & T(4)(6)I \\
		(8) & \((\forall x)[G(x) \limp \neg F(x)]\) & UG(7) \\
	\end{tblr}
\end{center}
\end{proof}
\end{example}
