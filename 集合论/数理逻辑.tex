\chapter{数理逻辑}

\section{数理逻辑概论}
\DefineConcept{逻辑}，作为英文单词 logic 的音译，指的是这样一种学科：
它研究如何正确地推理.
\DefineConcept{数理逻辑}（mathematical logic）则是逻辑学的一个分支，
它又被称为\DefineConcept{形式逻辑}（formal logic），
研究的范围则是命题、形式语言.

\subsection{命题的概念}
\DefineConcept{命题}（proposition），
是指对确定的对象进行判断的陈述句.
如果命题\(p\)的判断正确，
那么我们称“命题\(p\)是\DefineConcept{真的}（true）”，
或称“命题\(p\)是\DefineConcept{真命题}”；
如果命题\(p\)的判断错误，
那么我们称“命题\(p\)是\DefineConcept{假的}（false）”，
或称“命题\(p\)是\DefineConcept{假命题}”.

例如“太阳总从东方升起”“只有在冬天才下雪”“水是液体”“冰是固体”都是命题.

在给出若干命题后，我们通常会尝试找寻命题之间的关联性.
例如，已知“人固有一死”和“司马迁是人”，我们可以得出结论：“司马迁会死”.
像这样的思考方式，就是演绎推理.

\subsection{形式语言}
对于用汉语（或其他人类语言）表述的命题，
我们可能会因为它含糊不清的语义而无法作出真伪判断.
因此，数学家创造了一种独立于人类语言的、专门用于逻辑演绎的语言，
这就是\DefineConcept{形式语言}（formal language）.

下面我们讨论形式语言的三个方面：
\begin{enumerate}
	\item 指定形式语言使用的符号集、字母表.
	\item 制定一些规则，用以构造语法正确的有限符号串（即合式公式）.
	\item 指明形式语言与自然语言之间所允许的翻译.
\end{enumerate}


对于复杂的命题，我们可以将其看作是由若干个小命题组合而成的.
就像汉语中有“而且”“但是”等连接句子的虚词一样，
形式语言也有扮演相同角色的符号，这就是“逻辑联结词”.
\begin{table}[ht]
	\centering
	\begin{tabular}{*3c}
		\hline
		{\bf 概念} & {\bf 意义} & {\bf 符号} \\ \hline
		\DefineConcept{否定词}（negative） & 不、非 & \(\neg\) \\
		\DefineConcept{合取词}（conjunction） & 且、而且、并且 & \(\land\) \\
		\DefineConcept{析取词}（disjunction） & 或、或者 & \(\lor\) \\
		\DefineConcept{蕴涵词}（implication） & 如果……那么…… & \(\implies\) \\
		\DefineConcept{等价词}（equivalence） & 当且仅当 & \(\iff\) \\ \hline
	\end{tabular}
	\caption{逻辑联结词}
\end{table}

形式语言是由以下几种符号组成的：
\begin{enumerate}
	\item \DefineConcept{自由变元}（free variable），用小写拉丁字母表记.
	\item \DefineConcept{受限变元}（bound variable），也用小写拉丁字母表记.
	\item \DefineConcept{谓词}（predicate），目前有且只有一个：\(\in\).
	\item \DefineConcept{逻辑联结词}（logical connective），包括：\[
		\neg \qquad
		\lor \qquad
		\land \qquad
		\implies \qquad
		\iff \qquad
		\forall \qquad
		\exists.
	\]
	\item \DefineConcept{辅助符号}（auxiliary symbol），包括圆括号和方括号：\[
		( \qquad
		) \qquad
		[ \qquad
		]
	\]
\end{enumerate}

非形式地讲，
我们只要从上述符号中，可重复地选取有限个符号，写成一串，
就能得到一条\DefineConcept{命题公式}（proposition formula）.

在不引起误解的时候，我们也可将“命题公式”简称为\DefineConcept{公式}（formula）.

\begin{table}[ht]
	\centering
	\begin{subtable}[ht]{0.9\textwidth}
		\centering
		\begin{tabular}{|c|p{1.5cm}|}
			\hline
			\(p\) & \(\neg p\) \\ \hline
			0 & 1 \\ \hline
			1 & 0 \\ \hline
		\end{tabular}
		\caption{否定词“非”}
	\end{subtable}

	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \land q\) \\ \hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 0 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{合取词“且”}
	\end{subtable}
	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \lor q\) \\ \hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 1 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{析取词“或”}
	\end{subtable}

	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \implies q\) \\ \hline
			0 & 0 & 1 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{蕴涵词}
	\end{subtable}
	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \iff q\) \\ \hline
			0 & 0 & 1 \\ \hline
			0 & 1 & 0 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
	\caption{等价词}
	\end{subtable}
	\caption{真值表}
\end{table}

我们把命题\(p\)称为“命题\(p \implies q\)的\DefineConcept{蕴含前件}”
或“命题\(p \implies q\)的\DefineConcept{条件}”，
把命题\(q\)称为“命题\(p \implies q\)的\DefineConcept{蕴含后件}”
或“命题\(p \implies q\)的\DefineConcept{结论}”.

如果已知命题\(p \implies q\)是真命题，
则称“\(p\)是\(q\)的\DefineConcept{充分条件}”，
或称“\(q\)是\(p\)的\DefineConcept{必要条件}”.

如果已知\(p \implies q\)和\(q \implies p\)，
则称“\(p\)是\(q\)的\DefineConcept{充分必要条件}”，
或称“\(q\)是\(p\)的\DefineConcept{充分必要条件}”.
如果已知\(p \implies q\)和\(q \notimplies p\)，
则称“\(p\)是\(q\)的\DefineConcept{充分不必要条件}”，
或称“\(q\)是\(p\)的\DefineConcept{必要不充分条件}”.

如果命题\(p\)的条件是命题\(q\)的结论，
且命题\(p\)的结论是命题\(q\)的条件，
那么称“\(p\)和\(q\)是\DefineConcept{互逆命题}”；
称“\(q\)是\(p\)的\DefineConcept{逆命题}”
“\(p\)是\(q\)的逆命题”.

如果命题\(p\)的条件是命题\(q\)的条件的否定，
且命题\(p\)的结论是命题\(q\)的结论的否定，
那么称“\(p\)和\(q\)是\DefineConcept{互否命题}”；
称“\(q\)是\(p\)的\DefineConcept{否命题}”
“\(p\)是\(q\)的否命题”.

如果命题\(p\)的条件是命题\(q\)的结论的否定，
且命题\(p\)的结论是命题\(q\)的条件的否定，
那么称“\(p\)和\(q\)~\DefineConcept{互为逆否命题}”；
称“\(q\)是\(p\)的\DefineConcept{逆否命题}”
“\(p\)是\(q\)的逆否命题”.

\begin{figure}[htb]
	\centering
	\tikzstyle{prop} = [rectangle, minimum width=3cm, minimum height=2cm, text centered, draw=black, fill=orange!30]
	\tikzstyle{arrow} = [thick,<->,>=stealth]
	\begin{tikzpicture}[node distance=4cm]
		\node (p11) [prop] {\begin{tblr}{c}
			原命题 \\ \(p \implies q\)
		\end{tblr}};
		\node (p12) [prop, right=6cm of p11] {\begin{tblr}{c}
			逆命题 \\ \(q \implies p\)
		\end{tblr}};
		\node (p21) [prop, below of=p11] {\begin{tblr}{c}
			否命题 \\ \(\neg p \implies \neg q\)
		\end{tblr}};
		\node (p22) [prop, below of=p12] {\begin{tblr}{c}
			逆否命题 \\ \(\neg q \implies \neg p\)
		\end{tblr}};

		\begin{scope}[arrow]
			\draw (p11) -- node[anchor=south]{互逆} (p12);
			\draw (p11) -- node[anchor=east]{互否} (p21);
			\draw (p22) -- node[anchor=north]{互逆} (p21);
			\draw (p22) -- node[anchor=west]{互否} (p12);
			\draw (p11) -- node[sloped,near end,below]{互为逆否} (p22);
			\draw (p12) -- node[sloped,near end,above]{互为逆否} (p21);
		\end{scope}
	\end{tikzpicture}
	\caption{}
\end{figure}

可以观察发现，\(p \implies q\)的真值表与\([p \land \neg q]\)的恰好相反.
\begin{table}[ht]
	\centering
	\begin{tabular}{|*4{c|}}
		\hline
		\(p\) & \(q\) & \(\neg q\) & \(p \land \neg q\) \\ \hline
		0 & 0 & 1 & 0 \\ \hline
		0 & 1 & 0 & 0 \\ \hline
		1 & 0 & 1 & 1 \\ \hline
		1 & 1 & 0 & 0 \\ \hline
	\end{tabular}
	\caption{}
\end{table}



如果对于一个公式，不论其命题变元取何值，该公式总为真，
则称该公式为\DefineConcept{永真式}或\DefineConcept{重言式}.
常见的永真式有：
\begin{enumerate}
	\item 肯定后件律 \(p \implies (q \implies p)\)；
	\item 同一律 \(p \implies p\)；
	\item 排中律 \(\neg p \lor p\)；
	\item 矛盾律 \(\neg(\neg p \land p)\)；
	\item 双重否定律 \(\neg\neg p \iff p\).
\end{enumerate}


\subsection{合式公式}
我们将满足以下条件的公式称为\DefineConcept{合式公式}（well-formed formula）：%wff
\begin{enumerate}
	\item 如果\(a\)和\(b\)是自由变元，那么\([a \in b]\)是合式公式.
	这样的合式公式又被称为是\DefineConcept{原子的}（atomic），
	或者称这样的公式为\DefineConcept{原子公式}\footnote{%
	我们可以按公式中是否含有逻辑联结词，将命题公式分为两类：
	\DefineConcept{简单命题}（simple proposition）%
	或\DefineConcept{原子命题}（atom proposition），
	即不含有逻辑联结词的命题公式；
	以及\DefineConcept{复合命题}（compound proposition），
	即由简单命题和逻辑联结词构成的命题公式.
	}.

	\item 如果\(\phi\)和\(\psi\)是合式公式，那么\[
		\neg \phi, \qquad
		[\phi \lor \psi], \qquad
		[\phi \land \psi], \qquad
		[\phi \implies \psi], \qquad
		[\phi \iff \psi]
	\]都是合式公式.

	\item 如果\(\phi\)是合式公式，\(x\)是受限变元，那么\[
		(\forall x) \phi(x)
		\quad\text{和}\quad
		(\exists x) \phi(x)
	\]都是合式公式，
	其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
	用受限变元\(x\)代替某个自由变元\(a\)从而得到的公式.
	我们将这两个公式分别称为%
	“通过\DefineConcept{全称量化}变元\(a\)而从\(\phi\)得到的公式%
	（the formula obtained from \(\phi\) by universally quantifying on the variable \(a\)）”%
	和“通过\DefineConcept{存在量化}变元\(a\)而从\(\phi\)得到的公式%
	（the formula obtained from \(\phi\) by existentially quantifying on the variable \(a\)）”.
	%If \(\phi\) is a wff and x is a bound variable,
	%then \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) are wffs,
	%where \(\phi(x)\) is the formula obtained from the wff \(\phi\)
	%by replacing each occurrence of some free variable \(a\) by the bound variable \(x\).
	%We call \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) respectively,
	%the formula obtained from \(\phi\) by universally, or existentially,
	%quantifying on the variable \(a\).
\end{enumerate}
任意一条公式，当且仅当它可以由上述三条规则演绎推得时，我们才称其为合式公式.

\subsection{逻辑联结词的优先级}
我们解读形式语言的顺序和汉语、英语等常见人类语言一致.
除非命题公式有括号，否则我们总是按照从左到右的顺序，分析理解形式语言的含义.

在一些比较复杂的命题公式中常常有大量的括号，用来调整我们的解读顺序.
因此，为了简化书写，减少命题公式中括号的数目，我们可以规定逻辑联结词的优先级顺序：
\begin{definition}
设\(\phi,\psi,\eta\)都是合式公式.
定义：
\begin{enumerate}
	\item \(\phi
	\defiff
	(\phi)\).
	\item \((\neg\phi\land\psi)
	\defiff
	((\neg\phi)\land\psi)\).
	\item \((\phi\land\neg\psi)
	\defiff
	(\phi\land(\neg\psi))\).
	\item \((\neg\phi\lor\psi)
	\defiff
	((\neg\phi)\lor\psi)\).
	\item \((\phi\lor\neg\psi)
	\defiff
	(\phi\lor(\neg\psi))\).
	\item \((\neg\phi\implies\psi)
	\defiff
	((\neg\phi)\implies\psi)\).
	\item \((\phi\implies\neg\psi)
	\defiff
	(\phi\implies(\neg\psi))\).
	\item \((\neg\phi\iff\psi)
	\defiff
	((\neg\phi)\iff\psi)\).
	\item \((\phi\iff\neg\psi)
	\defiff
	(\phi\iff(\neg\psi))\).
	\item \((\phi\land\psi\lor\eta)
	\defiff
	((\phi\land\psi)\lor\eta)\).
	\item \((\phi\lor\psi\land\eta)
	\defiff
	(\phi\lor(\psi\land\eta))\).
	\item \((\phi\land\psi\implies\eta)
	\defiff
	((\phi\land\psi)\implies\eta)\).
	\item \((\phi\implies\psi\land\eta)
	\defiff
	(\phi\implies(\psi\land\eta))\).
	\item \((\phi\land\psi\iff\eta)
	\defiff
	((\phi\land\psi)\iff\eta)\).
	\item \((\phi\iff\psi\land\eta)
	\defiff
	(\phi\iff(\psi\land\eta))\).
	\item \((\phi\lor\psi\implies\eta)
	\defiff
	((\phi\lor\psi)\implies\eta)\).
	\item \((\phi\implies\psi\lor\eta)
	\defiff
	(\phi\implies(\psi\lor\eta))\).
	\item \((\phi\lor\psi\iff\eta)
	\defiff
	((\phi\lor\psi)\iff\eta)\).
	\item \((\phi\iff\psi\lor\eta)
	\defiff
	(\phi\iff(\psi\lor\eta))\).
	\item \((\phi\implies\psi\iff\eta)
	\defiff
	((\phi\implies\psi)\iff\eta)\).
	\item \((\phi\iff\psi\implies\eta)
	\defiff
	(\phi\iff(\psi\implies\eta))\).
\end{enumerate}
\end{definition}
非形式地说，逻辑联结词的优先级为：\[
	\neg, \qquad
	\land, \qquad
	\lor, \qquad
	\implies, \qquad
	\iff.
\]
在这里，最左边的运算符的优先级最高，凡是和其他运算符组合使用时，总要从它开始读起.

\begin{definition}
设\(\phi,\psi\)都是合式公式.
定义：
\((\neg(\phi\implies\psi))
\defiff
(\phi\notimplies\psi)\).
\end{definition}

\begin{example}
\([(\neg p) \lor (q)]\)等同于\([\neg p \lor q]\).
\end{example}

\begin{example}
\([p \implies q \land r \implies s]\)等同于\([(p \implies (q \land r)) \implies s]\).
\end{example}

\subsection{逻辑公理，推理规则}
我们有如下五条逻辑公理：
\begin{axiom}
\(\phi \implies [\psi \implies \phi]\).
\end{axiom}
\begin{axiom}
\([\phi \implies [\psi \implies \eta]] \implies [[\phi \implies \psi] \implies [\phi \implies \eta]]\).
\end{axiom}
\begin{axiom}
\([\neg\phi \implies \neg\psi] \implies [\psi \implies \phi]\).
\end{axiom}
\begin{axiom}
\((\forall x)[\phi \implies \psi(x)] \implies [\phi \implies (\forall x) \psi(x)]\)，
其中，我们量化的自由变元\(a\)没有出现在公式\(\phi\)中.
%where the free variable \(a\) on which we are quantifying does not occur in \(\phi\).
\end{axiom}
\begin{axiom}
\((\forall x) \phi(x) \implies \phi(a)\)，
其中，\(\phi(a)\)是通过用自由变元\(a\)代替\(\phi(x)\)中的受限变元\(x\)得到的公式.
%where \(\phi(a)\) is the forumla
%obtained by replacing each occurrence
%of the bound variable x
%in \(\phi(x)\) by the free variable \(a\).
\end{axiom}
以及如下两条\DefineConcept{推理规则}（rules of inference）：
\begin{axiom}
从\(\phi\)和\(\phi \implies \psi\)，可以推断\(\psi\).
%From \(\phi\) and \(\phi \implies \psi\) to infer \(\psi\).
\end{axiom}
\begin{axiom}
从\(\phi\)，可以推断\((\forall x) \phi(x)\)，
其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
用受限变元\(x\)代替某个自由变元从而得到的公式.
%From \(\phi\) to infer \((\forall x)\) \phi(x)
%where \(\phi(x)\) is obtained from \(\phi\)
%by replacing each occurrence of some free variable by x.
\end{axiom}
