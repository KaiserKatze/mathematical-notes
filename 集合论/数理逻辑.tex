\chapter{数理逻辑}

\section{数理逻辑概论}
\DefineConcept{逻辑}，作为英文单词 logic 的音译，指的是这样一种学科：
它研究如何正确地推理.
\DefineConcept{数理逻辑}（mathematical logic）则是逻辑学的一个分支，
它又被称为\DefineConcept{形式逻辑}（formal logic），
研究的范围则是命题、形式语言.

\subsection{命题的概念}
\DefineConcept{命题}（proposition），
是指对确定的对象进行判断的陈述句.
如果命题\(p\)的判断正确，
那么我们称“命题\(p\)是\DefineConcept{真的}（true）”，
或称“命题\(p\)是\DefineConcept{真命题}”；
如果命题\(p\)的判断错误，
那么我们称“命题\(p\)是\DefineConcept{假的}（false）”，
或称“命题\(p\)是\DefineConcept{假命题}”.

例如“太阳总从东方升起”“只有在冬天才下雪”“水是液体”“冰是固体”都是命题.

在给出若干命题后，我们通常会尝试找寻命题之间的关联性.
例如，已知“人固有一死”和“司马迁是人”，我们可以得出结论：“司马迁会死”.
像这样的思考方式，就是演绎推理.

\subsection{形式语言}
对于用汉语（或其他人类语言）表述的命题，
我们可能会因为它含糊不清的语义而无法作出真伪判断.
因此，数学家创造了一种独立于人类语言的、专门用于逻辑演绎的语言，
这就是\DefineConcept{形式语言}（formal language）.

下面我们讨论形式语言的三个方面：
\begin{enumerate}
	\item 指定形式语言使用的符号集、字母表.
	\item 制定一些规则，用以构造语法正确的有限符号串（即合式公式）.
	\item 指明形式语言与自然语言之间所允许的翻译.
\end{enumerate}


对于复杂的命题，我们可以将其看作是由若干个小命题组合而成的.
就像汉语中有“而且”“但是”等连接句子的虚词一样，
形式语言也有扮演相同角色的符号，这就是“逻辑联结词”.
\begin{table}[htb]
	\centering
	\begin{tabular}{*3c}
		\hline
		{\bf 概念} & {\bf 意义} & {\bf 符号} \\ \hline
		\DefineConcept{否定词}（negative） & 不、非 & \(\neg\) \\
		\DefineConcept{合取词}（conjunction） & 且、而且、并且 & \(\land\) \\
		\DefineConcept{析取词}（disjunction） & 或、或者 & \(\lor\) \\
		\DefineConcept{蕴涵词}（implication） & 如果……那么…… & \(\implies\) \\
		\DefineConcept{等价词}（equivalence） & 当且仅当 & \(\iff\) \\ \hline
	\end{tabular}
	\caption{逻辑联结词}
\end{table}

形式语言是由以下几种符号组成的：
\begin{enumerate}
	\item \DefineConcept{自由变元}（free variable），用小写拉丁字母表记.
	\item \DefineConcept{受限变元}（bound variable），也用小写拉丁字母表记.
	\item \DefineConcept{谓词}（predicate），目前有且只有一个：\(\in\).
	\item \DefineConcept{逻辑联结词}（logical connective），
	包括\DefineConcept{否定联结词}、
	\DefineConcept{合取联结词}、
	\DefineConcept{析取联结词}、
	\DefineConcept{异或联结词}、
	\DefineConcept{条件联结词}（或称\DefineConcept{蕴涵联结词}）、
	\DefineConcept{双条件联结词}（或称\DefineConcept{等价联结词}）、
	\DefineConcept{与非联结词}、
	\DefineConcept{或非联结词}、
	\DefineConcept{条件否定联结词}
	\footnote{%
		在研究数字电路时，
		我们通常用\(p \cdot q\)代替\(p \land q\)，
		用\(p + q\)代替\(p \lor q\)，
		用\(\overline{p \cdot q}\)代替\(p \lnand q\)，
		用\(\overline{p + q}\)代替\(p \lnor q\).
	}：\[
		\neg \qquad
		\land \qquad
		\lor \qquad
		\lxor \qquad
		\implies \qquad
		\iff \qquad
		\lnand \qquad
		\lnor \qquad
		\notimplies.
		% \forall \qquad
		% \exists.
	\]
	\item 辅助符号，包括圆括号、方括号等：\[
		( \qquad
		) \qquad
		[ \qquad
		]
	\]
\end{enumerate}

非形式地讲，
我们只要从上述符号中，可重复地选取有限个符号，写成一串，
就能得到一条\DefineConcept{命题公式}（proposition formula）.

在不引起误解的时候，我们也可将“命题公式”简称为\DefineConcept{公式}（formula）.

\begin{table}[htb]
	\centering
	\begin{subtable}[ht]{0.9\textwidth}
		\centering
		\begin{tabular}{|c|p{1.5cm}|}
			\hline
			\(p\) & \(\neg p\) \\ \hline
			0 & 1 \\ \hline
			1 & 0 \\ \hline
		\end{tabular}
		\caption{否定联结词}
	\end{subtable}

	\begin{subtable}[ht]{0.25\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \land q\) \\ \hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 0 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{合取联结词}
	\end{subtable}
	\begin{subtable}[ht]{0.3\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \lor q\) \\ \hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 1 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{析取联结词}
	\end{subtable}
	\begin{subtable}[ht]{0.3\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \lxor q\) \\ \hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 1 \\ \hline
			1 & 1 & 0 \\ \hline
		\end{tabular}
		\caption{异或联结词}
	\end{subtable}

	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \implies q\) \\ \hline
			0 & 0 & 1 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
		\caption{条件联结词}
	\end{subtable}
	\begin{subtable}[ht]{0.45\textwidth}
		\centering
		\begin{tabular}{|*{2}{c|}p{2cm}|}
			\hline
			\(p\) & \(q\) & \(p \iff q\) \\ \hline
			0 & 0 & 1 \\ \hline
			0 & 1 & 0 \\ \hline
			1 & 0 & 0 \\ \hline
			1 & 1 & 1 \\ \hline
		\end{tabular}
	\caption{等价联结词}
	\end{subtable}
	\caption{真值表}
\end{table}

我们把命题\(p\)称为“命题\(p \implies q\)的\DefineConcept{蕴含前件}”
或“命题\(p \implies q\)的\DefineConcept{条件}”，
把命题\(q\)称为“命题\(p \implies q\)的\DefineConcept{蕴含后件}”
或“命题\(p \implies q\)的\DefineConcept{结论}”.

如果已知命题\(p \implies q\)是真命题，
则称“\(p\)是\(q\)的\DefineConcept{充分条件}”，
或称“\(q\)是\(p\)的\DefineConcept{必要条件}”.

如果已知\(p \implies q\)和\(q \implies p\)，
则称“\(p\)是\(q\)的\DefineConcept{充分必要条件}”，
或称“\(q\)是\(p\)的\DefineConcept{充分必要条件}”.
如果已知\(p \implies q\)和\(q \notimplies p\)，
则称“\(p\)是\(q\)的\DefineConcept{充分不必要条件}”，
或称“\(q\)是\(p\)的\DefineConcept{必要不充分条件}”.

如果命题\(p\)的条件是命题\(q\)的结论，
且命题\(p\)的结论是命题\(q\)的条件，
那么称“\(p\)和\(q\)是\DefineConcept{互逆命题}”；
称“\(q\)是\(p\)的\DefineConcept{逆命题}”
“\(p\)是\(q\)的逆命题”.

如果命题\(p\)的条件是命题\(q\)的条件的否定，
且命题\(p\)的结论是命题\(q\)的结论的否定，
那么称“\(p\)和\(q\)是\DefineConcept{互否命题}”；
称“\(q\)是\(p\)的\DefineConcept{否命题}”
“\(p\)是\(q\)的否命题”.

如果命题\(p\)的条件是命题\(q\)的结论的否定，
且命题\(p\)的结论是命题\(q\)的条件的否定，
那么称“\(p\)和\(q\)~\DefineConcept{互为逆否命题}”；
称“\(q\)是\(p\)的\DefineConcept{逆否命题}”
“\(p\)是\(q\)的逆否命题”.

\begin{figure}[htb]
	\centering
	\tikzstyle{prop} = [rectangle, minimum width=3cm, minimum height=2cm, text centered, draw=black, fill=orange!30]
	\tikzstyle{arrow} = [thick,<->,>=stealth]
	\begin{tikzpicture}[node distance=4cm]
		\node (p11) [prop] {\begin{tblr}{c}
			原命题 \\ \(p \implies q\)
		\end{tblr}};
		\node (p12) [prop, right=6cm of p11] {\begin{tblr}{c}
			逆命题 \\ \(q \implies p\)
		\end{tblr}};
		\node (p21) [prop, below of=p11] {\begin{tblr}{c}
			否命题 \\ \(\neg p \implies \neg q\)
		\end{tblr}};
		\node (p22) [prop, below of=p12] {\begin{tblr}{c}
			逆否命题 \\ \(\neg q \implies \neg p\)
		\end{tblr}};

		\begin{scope}[arrow]
			\draw (p11) -- node[anchor=south]{互逆} (p12);
			\draw (p11) -- node[anchor=east]{互否} (p21);
			\draw (p22) -- node[anchor=north]{互逆} (p21);
			\draw (p22) -- node[anchor=west]{互否} (p12);
			\draw (p11) -- node[sloped,near end,below]{互为逆否} (p22);
			\draw (p12) -- node[sloped,near end,above]{互为逆否} (p21);
		\end{scope}
	\end{tikzpicture}
	\caption{}
\end{figure}

可以观察发现，\(p \implies q\)的真值表与\([p \land \neg q]\)的恰好相反.
\begin{table}[htb]
	\centering
	\begin{tabular}{|*4{c|}}
		\hline
		\(p\) & \(q\) & \(\neg q\) & \(p \land \neg q\) \\ \hline
		0 & 0 & 1 & 0 \\ \hline
		0 & 1 & 0 & 0 \\ \hline
		1 & 0 & 1 & 1 \\ \hline
		1 & 1 & 0 & 0 \\ \hline
	\end{tabular}
	\caption{}
\end{table}

给定命题公式\(A\)，对\(A\)中出现的每个命题变元都指定一个真值\(1\)或\(0\)，
就对命题公式\(A\)进行了一种\DefineConcept{真值指派}（assignment）
或一个\DefineConcept{解释}（interpretation），
而在该指派下可以求出命题公式\(A\)的真值.
将\(A\)的所有可能的真值指派以及它在每一个真值指派下的取值列成一张表，
就得到命题公式\(A\)的\DefineConcept{真值表}（truth table）.

在任何指派下均取真的命题公式，
称为\DefineConcept{永真式}或\DefineConcept{重言式}（tautology）.

在任何指派下均取假的命题公式，
称为\DefineConcept{永假式}或\DefineConcept{矛盾式}（contradiction）.

至少有一种指派使其为真的命题公式，
称为\DefineConcept{可满足式}（satisfactable formula）.

至少有一种指派使其为真，同时至少有一种指派使其为假的命题公式，
称为\DefineConcept{中性式}或\DefineConcept{偶然式}（contingency）.

常见的永真式有：
\begin{enumerate}
	\item 肯定后件律 \(p \implies (q \implies p)\)；
	\item 同一律 \(p \implies p\)；
	\item 排中律 \(\neg p \lor p\)；
	\item 矛盾律 \(\neg(\neg p \land p)\)；
	\item 双重否定律 \(\neg\neg p \iff p\).
\end{enumerate}

\begin{theorem}[永真式代入定理]
设命题公式\(A(p_1,p_2,\dotsc,p_n)\)是永真式，
则分别用命题公式\(B_1,B_2,\dotsc,B_n\)代换命题变元\(p_1,p_2,\dotsc,p_n\)，
所得到的命题公式\(A(B_1,B_2,\dotsc,B_n)\)也是永真式.
\end{theorem}
% \DefineConcept{代入实例}（substitution instance）

\subsection{合式公式}
我们将满足以下条件的公式称为\DefineConcept{合式公式}（well-formed formula）：%wff
\begin{enumerate}
	\item 如果\(a\)和\(b\)是自由变元，那么\([a \in b]\)是合式公式.
	这样的合式公式又被称为是\DefineConcept{原子的}（atomic），
	或者称这样的公式为\DefineConcept{原子公式}
	\footnote{%
		我们可以按公式中是否含有逻辑联结词，将命题公式分为两类：
		\DefineConcept{简单命题}（simple proposition）%
		或\DefineConcept{原子命题}（atom proposition），
		即不含有逻辑联结词的命题公式；
		以及\DefineConcept{复合命题}（compound proposition），
		即由简单命题和逻辑联结词构成的命题公式.
	}.

	\item 如果\(\phi\)和\(\psi\)是合式公式，那么\[
		\neg \phi, \qquad
		[\phi \lor \psi], \qquad
		[\phi \land \psi], \qquad
		[\phi \implies \psi], \qquad
		[\phi \iff \psi]
	\]都是合式公式.

	\item 如果\(\phi\)是合式公式，\(x\)是受限变元，那么\[
		(\forall x) \phi(x)
		\quad\text{和}\quad
		(\exists x) \phi(x)
	\]都是合式公式，
	其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
	用受限变元\(x\)代替某个自由变元\(a\)从而得到的公式.
	我们将这两个公式分别称为%
	“通过\DefineConcept{全称量化}变元\(a\)而从\(\phi\)得到的公式%
	（the formula obtained from \(\phi\) by universally quantifying on the variable \(a\)）”%
	和“通过\DefineConcept{存在量化}变元\(a\)而从\(\phi\)得到的公式%
	（the formula obtained from \(\phi\) by existentially quantifying on the variable \(a\)）”.
	%If \(\phi\) is a wff and x is a bound variable,
	%then \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) are wffs,
	%where \(\phi(x)\) is the formula obtained from the wff \(\phi\)
	%by replacing each occurrence of some free variable \(a\) by the bound variable \(x\).
	%We call \((\forall x) \phi(x)\) and \((\exists x) \phi(x)\) respectively,
	%the formula obtained from \(\phi\) by universally, or existentially,
	%quantifying on the variable \(a\).
\end{enumerate}
任意一条公式，当且仅当它可以由上述三条规则演绎推得时，我们才称其为合式公式.

\subsection{逻辑联结词的优先级}
我们解读形式语言的顺序和汉语、英语等常见人类语言一致.
除非命题公式有括号，否则我们总是按照从左到右的顺序，分析理解形式语言的含义.

在一些比较复杂的命题公式中常常有大量的括号，用来调整我们的解读顺序.
因此，为了简化书写，减少命题公式中括号的数目，我们可以规定逻辑联结词的优先级顺序：
\begin{definition}
设\(\phi,\psi,\eta\)都是合式公式.
定义：
\begin{enumerate}
	\item \(\phi
	\defiff
	(\phi)\).
	\item \((\neg\phi\land\psi)
	\defiff
	((\neg\phi)\land\psi)\).
	\item \((\phi\land\neg\psi)
	\defiff
	(\phi\land(\neg\psi))\).
	\item \((\neg\phi\lor\psi)
	\defiff
	((\neg\phi)\lor\psi)\).
	\item \((\phi\lor\neg\psi)
	\defiff
	(\phi\lor(\neg\psi))\).
	\item \((\neg\phi\implies\psi)
	\defiff
	((\neg\phi)\implies\psi)\).
	\item \((\phi\implies\neg\psi)
	\defiff
	(\phi\implies(\neg\psi))\).
	\item \((\neg\phi\iff\psi)
	\defiff
	((\neg\phi)\iff\psi)\).
	\item \((\phi\iff\neg\psi)
	\defiff
	(\phi\iff(\neg\psi))\).
	\item \((\phi\land\psi\lor\eta)
	\defiff
	((\phi\land\psi)\lor\eta)\).
	\item \((\phi\lor\psi\land\eta)
	\defiff
	(\phi\lor(\psi\land\eta))\).
	\item \((\phi\land\psi\implies\eta)
	\defiff
	((\phi\land\psi)\implies\eta)\).
	\item \((\phi\implies\psi\land\eta)
	\defiff
	(\phi\implies(\psi\land\eta))\).
	\item \((\phi\land\psi\iff\eta)
	\defiff
	((\phi\land\psi)\iff\eta)\).
	\item \((\phi\iff\psi\land\eta)
	\defiff
	(\phi\iff(\psi\land\eta))\).
	\item \((\phi\lor\psi\implies\eta)
	\defiff
	((\phi\lor\psi)\implies\eta)\).
	\item \((\phi\implies\psi\lor\eta)
	\defiff
	(\phi\implies(\psi\lor\eta))\).
	\item \((\phi\lor\psi\iff\eta)
	\defiff
	((\phi\lor\psi)\iff\eta)\).
	\item \((\phi\iff\psi\lor\eta)
	\defiff
	(\phi\iff(\psi\lor\eta))\).
	\item \((\phi\implies\psi\iff\eta)
	\defiff
	((\phi\implies\psi)\iff\eta)\).
	\item \((\phi\iff\psi\implies\eta)
	\defiff
	(\phi\iff(\psi\implies\eta))\).
\end{enumerate}
\end{definition}
非形式地说，逻辑联结词的优先级为：\[
	\neg, \qquad
	\land, \qquad
	\lor, \qquad
	\implies, \qquad
	\iff.
\]
在这里，最左边的运算符的优先级最高，凡是和其他运算符组合使用时，总要从它开始读起.

\begin{definition}
设\(\phi,\psi\)都是合式公式.
定义：
\((\neg(\phi\implies\psi))
\defiff
(\phi\notimplies\psi)\).
\end{definition}

\begin{example}
\([(\neg p) \lor (q)]\)等同于\([\neg p \lor q]\).
\end{example}

\begin{example}
\([p \implies q \land r \implies s]\)等同于\([(p \implies (q \land r)) \implies s]\).
\end{example}

\subsection{逻辑公理，推理规则}
我们有如下五条逻辑公理：
\begin{axiom}
\(\phi \implies [\psi \implies \phi]\).
\end{axiom}
\begin{axiom}
\([\phi \implies [\psi \implies \eta]] \implies [[\phi \implies \psi] \implies [\phi \implies \eta]]\).
\end{axiom}
\begin{axiom}
\([\neg\phi \implies \neg\psi] \implies [\psi \implies \phi]\).
\end{axiom}
\begin{axiom}
\((\forall x)[\phi \implies \psi(x)] \implies [\phi \implies (\forall x) \psi(x)]\)，
其中，我们量化的自由变元\(a\)没有出现在公式\(\phi\)中.
%where the free variable \(a\) on which we are quantifying does not occur in \(\phi\).
\end{axiom}
\begin{axiom}
\((\forall x) \phi(x) \implies \phi(a)\)，
其中，\(\phi(a)\)是通过用自由变元\(a\)代替\(\phi(x)\)中的受限变元\(x\)得到的公式.
%where \(\phi(a)\) is the forumla
%obtained by replacing each occurrence
%of the bound variable x
%in \(\phi(x)\) by the free variable \(a\).
\end{axiom}
以及如下两条\DefineConcept{推理规则}（rules of inference）：
\begin{axiom}
从\(\phi\)和\(\phi \implies \psi\)，可以推断\(\psi\).
%From \(\phi\) and \(\phi \implies \psi\) to infer \(\psi\).
\end{axiom}
\begin{axiom}
从\(\phi\)，可以推断\((\forall x) \phi(x)\)，
其中，\(\phi(x)\)表示在合式公式\(\phi\)中，
用受限变元\(x\)代替某个自由变元从而得到的公式.
%From \(\phi\) to infer \((\forall x)\) \phi(x)
%where \(\phi(x)\) is obtained from \(\phi\)
%by replacing each occurrence of some free variable by x.
\end{axiom}

\subsection{逻辑等值}
\begin{definition}
给定两个命题公式\(A\)和\(B\)，
如果在任何真值指派下，\(A\)和\(B\)的真值都相同，
则称“命题公式\(A\)和\(B\) \DefineConcept{逻辑等值}（logically equal）”
或“命题公式\(A\)和\(B\) \DefineConcept{逻辑等价}（logically equivalent）”，
记为\(A = B\).
\end{definition}
\begin{remark}
注意不要混淆“逻辑等价”与“等价联结词”这两个概念.
\end{remark}
\begin{theorem}
设\(A\)和\(B\)是命题公式，
则\(A = B\)的充分必要条件是\(A \iff B\)是永真式.
%TODO proof
\end{theorem}

\begin{example}
证明：对于任意命题公式\(A,B\)，
有\begin{equation}\label{equation:数理逻辑.蕴含式化为析取式}
	A \implies B = \neg A \lor B.
\end{equation}
\begin{proof}
列出真值表：\begin{center}
	\begin{tblr}{*5{|c}|}
		\hline
		\(p\) & \(q\) & \(p \implies q\) & \(\neg p\) & \(\neg p \lor q\) \\
		\hline
		0 & 0 & 1 & 1 & 1 \\
		0 & 1 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 & 0 \\
		1 & 1 & 1 & 0 & 1 \\
		\hline
	\end{tblr}
\end{center}
显然有\(A \implies B = \neg A \lor B\).
\end{proof}
\end{example}

\begin{theorem}
对于任意命题公式\(A,B,C\)，有\begin{itemize}
	\item {\rm\bf 自反性}：\(A = A\).
	\item {\rm\bf 对称性}：若\(A = B\)，则\(B = A\).
	\item {\rm\bf 传递性}：若\(A = B\)且\(B = C\)，则\(A = C\).
\end{itemize}
%TODO proof
\end{theorem}

\begin{theorem}[基本等值式]
对于任意命题公式\(A,B,C\)，有\begin{itemize}
	\item {\rm\bf 对合律}：\(\neg\neg A = A\).
	\item {\rm\bf 幂等律}（或称{\rm\bf 重叠律}）：\begin{itemize}
		\item \(A \lor A = A\)
		\item \(A \land A = A\)
	\end{itemize}
	\item {\rm\bf 交换律}：\begin{itemize}
		\item \(A \lor B = B \lor A\)
		\item \(A \land B = B \land A\)
	\end{itemize}
	\item {\rm\bf 结合律}：\begin{itemize}
		\item \((A \lor B) \lor C = A \lor (B \lor C)\)
		\item \((A \land B) \land C = A \land (B \land C)\)
	\end{itemize}
	\item {\rm\bf 吸收律}：\begin{itemize}
		\item \(A \lor (A \land B) = A\)
		\item \(A \land (A \lor B) = A\)
	\end{itemize}
	\item {\rm\bf 分配律}：\begin{itemize}
		\item \(A \lor (B \land C) = (A \lor B) \land (A \lor C)\)
		\item \(A \land (B \lor C) = (A \land B) \lor (A \land C)\)
	\end{itemize}
	\item {\rm\bf 互补律}：\begin{itemize}
		\item \(A \lor \neg A = 1\)
		\item \(A \land \neg A = 0\)
	\end{itemize}
	\item {\rm\bf De Morgan 律}：\begin{itemize}
		\item \(\neg(A \lor B) = \neg A \land \neg B\).
		\item \(\neg(A \land B) = \neg A \lor \neg B\).
	\end{itemize}
	\item {\rm\bf 同一律}：\begin{itemize}
		\item \(A \lor 0 = 0 \lor A = A\)
		\item \(A \land 1 = 1 \land A = A\)
	\end{itemize}
	\item {\rm\bf 0-1 律}：\begin{itemize}
		\item \(A \lor 1 = 1 \lor A = 1\)
		\item \(A \land 0 = 0 \land A = 0\)
	\end{itemize}
\end{itemize}
\end{theorem}
\begin{remark}
基本等值式可以用于：\begin{itemize}
	\item 化简命题公式；
	\item 判断命题公式的类型；
	\item 证明等值式；
	\item 计算命题公式的范式；
	\item 命题逻辑推理.
\end{itemize}
\end{remark}

对于任意命题公式\(A,B\)，有\begin{itemize}
	\item \(A \lxor B
	= \neg(A \iff B)
	= (A \land \neg B) \lor (\neg A \land B)\).
	\item \(A \implies B
	= \neg A \lor B\).
	\item \(A \iff B
	= (A \implies B) \land (B \implies A)\).
	\item \(A \lnand B
	= \neg(A \land B)\).
	\item \(A \lnor B
	= \neg(A \lor B)\).
	\item \(A \notimplies B
	= \neg(A \implies B)\).
\end{itemize}

\begin{theorem}[等值置换定理]
设\(C\)是命题公式\(A\)的子公式，且\(C = D\)，
则将\(A\)中的\(C\)部分或全部替换成\(D\)所得到的命题公式与\(A\)等值.
%TODO proof
\end{theorem}

\subsection{对偶原理}
\begin{definition}
设命题公式\(A\)中至多含有3个逻辑联结词\(\neg,\land,\lor\).
将\(A\)中\(\land\)换成\(\lor\)，\(\lor\)换成\(\land\)，\(1\)换成\(0\)，\(0\)换成\(1\)，
所得到的命题公式称为“\(A\)的\DefineConcept{对偶式}（dual formula）”，记为\(A^*\).
\end{definition}

\begin{theorem}[对偶原理]
设\(A\)和\(B\)是命题公式.
若\(A = B\)，则\(A^* = B^*\).
\end{theorem}

\section{命题公式的范式}
给定一个命题公式，根据它的真值表，显然可以方便地得出它在每一种指派下的真值.
但是随着命题变元个数\(N\)的增加，命题公式的真值指派就有\(2^N\)种，在实际计算中就变成不可行的了.

\begin{definition}
设\(A\)是命题公式.
若\[
	A = A_1 \lor A_2 \lor \dotsb \lor A_n
	\quad(n\geq1),
\]
其中\(A_i\ (i=1,2,\dotsc,n)\)是由命题变元或其否定组成的合取式，
则称“\(A_1 \lor A_2 \lor \dotsb \lor A_n\)是
\(A\)的\DefineConcept{析取范式}（disjunctive normal form）”.
\end{definition}

\begin{definition}
设\(A\)是命题公式.
若\[
	A = A_1 \land A_2 \land \dotsb \land A_n
	\quad(n\geq1),
\]
其中\(A_i\ (i=1,2,\dotsc,n)\)是由命题变元或其否定组成的析取式，
则称“\(A_1 \land A_2 \land \dotsb \land A_n\)是
\(A\)的\DefineConcept{合取范式}（conjunctive normal form）”.
\end{definition}

可以证明：任意一个命题公式都存在析取范式与合取范式.

计算析取范式、合取范式的步骤：\begin{enumerate}
	\item 使用等值式，将命题公式中的联结词归约为\(\neg,\land,\lor\)；
	\item 利用 De Morgan 律，将\(\neg\)移到命题变元的前面；
	\item 根据分配律，得到命题公式的析取范式、合取范式.
\end{enumerate}

\begin{example}
设\(p,q,r\)都是命题变元.
求命题公式\(A = p \implies q \iff r\)的析取范式、合取范式.
\begin{solution}
由等值式得\begin{align*}
	A &= p \implies q \iff r \\
	&= (\neg p \lor q \implies r) \land (r \implies \neg p \lor q) \\
	&= (\neg(\neg p \lor q) \lor r) \land (\neg r \lor (\neg p \lor q)) \\
	&= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r).
\end{align*}
于是\(A\)的析取范式为\begin{align*}
	A &= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \land \neg q) \land (\neg p \lor q \lor \neg r)
		\lor r \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \land \neg q) \land \neg p
		\lor (p \land \neg q) \land q
		\lor (p \land \neg q) \land \neg r
		\lor r \land \neg p
		\lor r \land q
		\lor r \land \neg r \\
	% 吸收律，消去\(p \land \neg p\)、\(q \land \neg q\)和\(r \land \neg r\)
	&= p \land \neg q \land \neg r
		\lor \neg p \land r
		\lor q \land r,
\end{align*}
\(A\)的合取范式为\begin{align*}
	A &= (p \land \neg q \lor r) \land (\neg p \lor q \lor \neg r) \\
	% 分配律
	&= (p \lor r) \land (\neg q \lor r) \land (\neg p \lor q \lor \neg r).
\end{align*}
\end{solution}
\end{example}

根据命题公式的析取范式、合取范式，可以分别得出该命题公式的成真指派、成假指派.
例如，已知\(A\)的析取范式是
\(A = p \land \neg q \land \neg r
\lor \neg p \land r
\lor q \land r\)，
若要\(A\)取\(1\)，
则\[
	p \land \neg q \land \neg r,
	\qquad
	\neg p \land r
	\qquad
	q \land r
\]至少一个为\(1\)，
由\(p \land \neg q \land \neg r = 1\)得\((p,q,r) = (1,0,0)\)，
由\(\neg p \land r = 1\)得\((p,q,r) = (0,1,1),(0,0,1)\)，
由\(q \land r = 1\)得\((p,q,r) = (1,1,1),(0,1,1)\)，
于是，\(A\)的成真指派有\[
	(1,0,0),
	(0,1,1),
	(0,0,1),
	(1,1,1).
\]
同样地，由\(A\)的合取范式
\(A = (p \lor r) \land (\neg q \lor r) \land (\neg p \lor q \lor \neg r)\)可知，
\(A\)的成假指派有\[
	(1,0,1),
	(1,1,0),
	(0,1,0),
	(0,0,0).
\]

一般来说，一个命题公式的析取范式、合取范式都不是唯一的.
例如，假设\(A = p\)，
那么\((p \land q) \lor (p \land \neg q)\)和\(p\)都是\(A\)的析取范式.
这种不唯一性给有些问题的讨论带来不便.
下面根据命题公式的所有命题变元，讨论给定命题公式的唯一的标准形式：
\DefineConcept{主析取范式}和\DefineConcept{主合取范式}.

\begin{definition}
对于给定的命题变元，若由命题变元或其否定组成的合取式满足\begin{itemize}
	\item 每个命题变元或其否定两者之一只出现一次，
	\item 按字典顺序或按下标从小到大顺序出现，
\end{itemize}
则称该合取式为“由所给命题变元产生的\DefineConcept{极小项}（minimal term）”.
\end{definition}

可以证明：对于每一个极小项，只有一种指派使其取\(1\).

根据这个结论，我们可以对极小项编码：
极小项用\(m_i\)表示，
其中下标\(i\)是由成真指派得到的二进制数或对应的十进制数.

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极小项 & 成真指派 & 极小项的符号表示\(m_i\) \\
		\hline
		\(p \land q\) & 11 & \(m_{11} = m_3\) \\
		\(p \land \neg q\) & 10 & \(m_{10} = m_2\) \\
		\(\neg p \land q\) & 01 & \(m_{01} = m_1\) \\
		\(\neg p \land \neg q\) & 00 & \(m_{00} = m_0\) \\
		\hline
	\end{tblr}
	\caption{由2个命题变元\(p,q\)产生的极小项及其成真指派、符号表示}
\end{table}

\begin{table}[ht]
	\centering
	\begin{tblr}{c|c|c}
		\hline
		极小项 & 成真指派 & 极小项的符号表示\(m_i\) \\
		\hline
		\(p \land q \land r\) & 111 & \(m_{111} = m_7\) \\
		\(p \land q \land \neg r\) & 110 & \(m_{110} = m_6\) \\
		\(p \land \neg q \land r\) & 101 & \(m_{101} = m_5\) \\
		\(p \land \neg q \land \neg r\) & 100 & \(m_{100} = m_4\) \\
		\(\neg p \land q \land r\) & 011 & \(m_{011} = m_3\) \\
		\(\neg p \land q \land \neg r\) & 010 & \(m_{010} = m_2\) \\
		\(\neg p \land \neg q \land r\) & 001 & \(m_{001} = m_1\) \\
		\(\neg p \land \neg q \land \neg r\) & 000 & \(m_{000} = m_0\) \\
		\hline
	\end{tblr}
	\caption{由3个命题变元\(p,q,r\)产生的极小项及其成真指派、符号表示}
\end{table}

\begin{definition}
对于命题公式\(A\)，
若由\(A\)中所有命题变元产生的若干个极小项的析取等值于\(A\)，
则把该析取式称为“\(A\)的\DefineConcept{主析取范式}（major disjunctive form）”.
\end{definition}
\begin{remark}
对于命题公式\(A = A(p_1,p_2,\dotsc,p_n)\)，
它的所有极小项的析取是永真式\(1\)，
它的0个极小项的析取是永假式\(0\)，
在这两种极端情况下\(A\)的主析取范式均不存在.
除了上述两种情况外，\(A\)均为中性式.
\end{remark}

利用等值演算法，求命题公式\(A\)的主析取范式的计算步骤：\begin{enumerate}
	\item 求出\(A\)的析取范式；
	\item 利用分配律，补充析取范式缺少的命题变元.
\end{enumerate}
