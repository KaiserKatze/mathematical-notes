\section{二分法}
由\hyperref[theorem:极限.零点定理]{零点定理}可知，
若连续函数\(f\)在闭区间\([a,b]\)的两个端点的函数值异号，
则在开区间\((a,b)\)内一定存在\(f\)的零点.
不妨设\(f(a) < 0, f(b) > 0\).
为了找出开区间\((a,b)\)内的零点\(x^*\)，
可以使用“二分法”缩小区间.
具体步骤如下：
首先取中点\(x_0 \defeq \frac12 (a + b)\).
如果恰有\(f(x_0) = 0\)，那当然再好不过了，说明\(x_0\)是\(f\)的零点.
反过来，如果\(f(x_0) \neq 0\)，则\(f(x_0) < 0\)和\(f(x_0) > 0\)二者必居其一.
如果\(f(x_0) < 0\)，
再次运用零点定理，可知\((x_0,b)\)内存在\(f\)的零点，
于是可以令\(a_1 \defeq x_0, b_1 \defeq b\).
如果\(f(x_0) > 0\)，
则\((a,x_0)\)内存在\(f\)的零点，
于是可以令\(a_1 \defeq a, b_1 \defeq x_0\).
接着取中点\(x_1 \defeq \frac12 (a_1 + b_1)\).
如果\(f(x_1) < 0\)，
则令\(a_2 \defeq x_1, b_2 \defeq b_1\).
如果\(f(x_1) > 0\)，
则令\(a_2 \defeq a_1, b_2 \defeq x_1\).
以此类推，有\((a,b) \supset (a_1,b_1) \supset (a_2,b_2) \supset \dotsb \supset (a_n,b_n) \ni x^*\).
由于\((a_{n+1},b_{n+1})\)的长度是\((a_n,b_n)\)的长度的一半，
所以我们把这种方法称为\DefineConcept{二分法}.
当\(n\to\infty\)时，\((a_n,b_n)\)的长度\(b_n - a_n = (b - a) / 2^n\)趋于零，
也就是说，只要二分过程无限地继续下去，区间序列\(\{(a_n,b_n)\}_{n\geq1}\)最终必定收缩于\(f\)的零点\(x^*\).
因此，在每次二分后，我们可以取区间\((a_n,b_n)\)的中点\(x_n \defeq (a_n + b_n) / 2\)作为零点的近似值.
容易看出，用\(x_n\)近似\(x^*\)产生的绝对误差为\(\abs{x^* - x_n} \leq (b_n - a_n) / 2 = (b - a) / 2^{n+1}\)，
那么只要二分足够多次（即\(n\)充分大），便有\(\abs{x^* - x_n} < \epsilon\)，其中\(\epsilon\)是预定精度.

\begin{algorithm}[用二分法求函数零点]
\hfill
\begin{enumerate}
	\item 准备：计算函数\(f\)在区间\([a,b]\)端点的值\(f(a),f(b)\)；
	\item 二分：计算函数\(f\)在区间中点\(t \defeq \frac{a+b}{2}\)的值\(\mu \defeq f(t)\)；
	\item 判断：\begin{itemize}
		\item 若\(\mu = 0\)，则\(t\)是零点，计算结束；
		\item 若\(\mu \cdot f(a) < 0\)，则令\(b \defeq t\)；
		\item 若\(\mu \cdot f(a) > 0\)，则令\(a \defeq t\)；
	\end{itemize}
	\item 判断：\begin{itemize}
		\item 如果区间\([a,b]\)的长度不小于预期误差\(\epsilon\)，则重复步骤2和步骤3；
		\item 否则，取中点\(t\)作为零点的近似值.
	\end{itemize}
\end{enumerate}
\end{algorithm}

二分法的优点是算法简单，并且它总是收敛的，
缺点是收敛太慢，因此通常不单独使用二分法求解零点，而是用它求出一个较好的近似值.
